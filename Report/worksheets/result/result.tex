\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Comparison of Results}{1}{April 24, 2013}{Andreas}{../../}
This chapter presents a comparison of the selected concurrency models and their characteristics. The comparison leads up to a description of when to apply each of the selected concurrency models.
\label{chap:results}

\kasper[inline]{Boxing af integers i Java implementation. int[] halverede tid sammemlignet med ArrayList<Integer>}
\andreas[inline]{Actors er svært at bruge hvis der er en eksisterende kodebase, da det kræver en modelering fra bunden. Actors kræver, at hele systemet bliver designet omkring det.}
\section{Characteristics}
This section presents a characteristics based comparison of the selected concurrency models.

\subsection{Implicit or Explicit Concurrency}
The placements of the three concurrency models on the implicit to explicit spectrum are shown in \bsref{fig:results_char_impli_expli}.

\ac{TL} and \ac{STM} are both placed high on the explicit end of the scale. They both require the programmer to explicitly manage threads and either use locks or transactions for marking critical regions. The actor model is more implicit than the other models as it hides the concepts of marking critical regions and low level threads. The actor model does however introduce new constructs, in the form of actors and messages, that must be explicitly used for programming concurrent programs.

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/result/figures/results_char_implicit_explicit} 
 \caption{Selected concurrency model on the Implicit - Explicit concurrency spectrum}
\label{fig:results_char_impli_expli}
\end{figure}

\subsection{Fault Restrictive or Expressive Model}
\bsref{fig:results_char_fault_expressive} shows how the three concurrency models are placed on the fault restrictive to expressive spectrum.

\ac{STM} and \ac{TL} are both placed towards the expressive end of the scale. \ac{TL} forces very few restrictions upon the programmer which gives him freedom in relation to expressing low-level synchronization details. However, this is on the cost of the programmer being left alone in ensuring correct execution. \ac{STM} is more fault restrictive than \ac{TL} as it delegates the low-level synchronization details to the STM system. 

The actor model on the other hand is towards the fault restrictive end, as it forces many restrictions on the programmer. It allows only isolated state and communication is limited to asynchronous message passing. Furthermore the design of the model disallows multiple reads operations to happen simultaneously. Lastly, it is only possible to model concurrency with actor and the interaction between them through messages, which means it is not possible to use threads directly.

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/result/figures/results_char_fault_expressive} 
 \caption{Selected concurrency models on the Fault Restrictive - Expressive spectrum}
\label{fig:results_char_fault_expressive}
\end{figure}

\subsection{Pessimistic or Optimistic Model}
\bsref{fig:results_char_pes_opti} shows the placement of the selected concurrency models on the Pessimistic - Optimistic spectrum. \ac{TL} and the actor model are pessimistic while \ac{STM} is an optimistic concurrency model. \ac{TL} guards against race conditions by providing mutual exclusion and the actor model enforces state encapsulation guarding against race conditions. \ac{STM} attempts to execute its transactions concurrently and retries the transactions if any conflicts occur.

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/result/figures/results_char_pessimistic_optemistic} 
 \caption{Selected concurrency models on the Pessimistic - Optimistic spectrum}
\label{fig:results_char_pes_opti}
\end{figure}

\subsection{Simplicity}
\bsref{fig:results_char_simplicity} shows the placement of the selected concurrency models on the low - high simplicity spectrum. The \ac{TL} concurrency model has low simplicity due to the number of concurrency related errors, programmers have to reason about. The implicit relationship between the data to which synchronization is applied and the synchronization itself exacerbates.

\ac{STM} and the actor model are more simple models, but both of the models fail to reach the high simplicity extreme due to a number of concurrency related issues. \ac{STM} suffers from the same implicit relation ships between data and synchronization that the \ac{TL} concurrency model also had. While \ac{STM} eliminates the issue of deadlocks, it has problems combining with existing language construct such as exceptions and \ac{IO}. Studies have shown that the concept of memory transactions can be hard to grasp for novice programmers.

The actor model is the most simple of the three selected concurrency models. It does however still have a number of issues reducing its simplicity. Many programmers are used to the school of thought know from imperative \ac{OOP}. The actor model employs different school of thought that programmers will have to be familiar with in order to create well structured programs. The asynchronous nature of the model be a problem in scenarios where synchronous would be beneficial.

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/result/figures/results_char_simplicity} 
 \caption{Selected concurrency models on the low - high simplicity spectrum}
\label{fig:results_char_simplicity}
\end{figure}

\subsection{Orthogonality}
The placements of the three concurrency models on the orthogonality spectrum are shown in \bsref{fig:results_char_orthogonality}. All the models are placed between the middle and high end of the orthogonality spectrum.

The actor model is highly orthogonal as it embodies only the two constructs of actors and messages which can be combined in a large number of ways. There are however some combinations which are only possible indirectly by using additional actors, such as sending a message to multiple actors at the same time. Furthermore some combinations can produce deadlocks which are undesirable, but embracing the non-deterministic nature of asynchronous message passing helps avoid these. The indirect and deadlock combinations keeps the model from being truly orthogonal.

\ac{STM} consists of the thread and transaction constructs\toby{Skal vi snakke om at de kommunikere gennem shared memory og synkroniserer over transaktioner?} that also can be combined in a number of ways. However, transactions have problems
composing with existing programming concepts such as IO, exceptions and
native method calls which results in the placement on the spectrum between middle and high orthogonality.

Lastly, \ac{TL} consists of the thread and lock constructs that are also possible to combine in a large number of ways. However the model makes it fairly easy to mistakenly produce combinations that can lead to program errors, such as deadlocks, which are hard to detect and recover from. This has a high negative impact on the orthogonality and is the reason why \ac{TL} has been placed lowest on the orthogonality spectrum of the three models.

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/result/figures/results_char_orthogonality} 
 \caption{Selected concurrency models on the low - high orthogonality spectrum}
\label{fig:results_char_orthogonality}
\end{figure}

\subsection{Readability}
\bsref{fig:results_char_readability} depicts the placement of the selected concurrency models on the low - high readability spectrum. The \ac{TL} has the lowest readability due to its implicit relationship between data and synchronization as well as fragmentation of the implementation. In order to reason about deadlocks the programmer has to reason about every point in which locking is applied as well as how these code segments interact. This has proven to be no easy task.

\ac{STM} is placed just below the middle of the spectrum. \ac{STM} removes the issues of deadlocks but still suffers from a implicit relationship between data and synchronization as well as code fragmentation. Understanding the concept of transactions can be hard for novice programmers and predicting their performance can be problematic. \ac{STM} handles composability by allowing transactions to be nested. 

The actor model encapsulates functionality and concurrency related code within actors. Due to actors only interacting via asynchronous message passing an actor can be viewed as an isolated computational agent, allowing its functionality to be understood by examining how it reacts to messages. While each actor can be reasoned about separately, reasoning about the systems as a whole is harder. Distributing functionality throughout actors fragments the functionality making it difficult to gain an overview. Allowing actors to create new actors exacerbates the problem limiting the readability of the model.

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/result/figures/results_char_readability} 
 \caption{Selected concurrency models on the low - high readability spectrum}
\label{fig:results_char_readability}
\end{figure}

\subsection{Level of abstraction}

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/result/figures/results_char_level_of_abstraction} 
 \caption{Selected concurrency models on the low - high level of abstraction spectrum}
\label{fig:results_char_level_of_abstraction}
\end{figure}

\subsection{Expressivity}

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/result/figures/results_char_expressivity} 
 \caption{Selected concurrency models on the low - high expressivity spectrum}
\label{fig:results_char_expressivity}
\end{figure}

\subsection{Writability evaluation}

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/result/figures/results_char_writability} 
 \caption{Selected concurrency models on the low - high writability spectrum}
\label{fig:results_char_writability}
\end{figure}

\section{\acl{TL}}
\section{\acl{STM}}
\section{Actor Model}
\worksheetend
