\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Preliminary Analysis}{1}{September 22, 2014}{Everybody}{../../}
% Formål med preliminary analysis
This chapter contains an analysis of prior work related to concurrency. It will be conducted by investigating papers, articles, and other research material of relevance, in order to discover state of the art, and open problems within the area of concurrency models. The purpose of the analysis is to establish an overview which will be used to choose the further path of our investigation.
\label{chap:preliminary_analysis}
% Moores law, skalér med flere kerner, ikke højere CPU
% Krav til at applikationer kræver mere ydelse
% Focus på skalering til flere computere i.e. parallel computing, ikke kun flere kerner
% Brug for en evolution, inden for tilgange til at skrive parallele programmer
% Vi vil kigge på concurrency inden for rammerne af samme maskine

%Threads and locks duer ikke
%Hvad er der behov for
%Hvad andet findes der, der opfylder behovet
\section{Related work}
\lone[inline]{Hvad er current state of the art, related work, open problem?}

In ``The Free Lunch is Over''\cite{sutter2005free}, it is claimed that the era of gaining performance increase without changing a program was over. 

\bsqoute{[...] if you want your application to benefit from the continued exponential throughput advances in new processors, it will need to be a well-written concurrent [...] application. And that’s easier said than done, because not all problems are inherently parallelizable and because concurrent programming is hard.}{Herb Sutter}

Hardware limitations in the processor development is having an impact on the way software should be developed to utilize the full potential of multi-core processors. Different approaches for writing concurrent programs have emerged. Language constructs such as \ac{TL} have been used to control the interaction between threads in order to enforce synchronization at key points. First off, the programmer is left alone to place the locks in the correct place and the correct order, which in itself is hard. If he succeeds of using locks as synchronization mechanism, a major caveat is that they are not composable\cite[p. 58]{sutter2005software}. That is, you cannot compose two correct lock-based pieces of code and know the result is still correct. This significantly limits the reuseability of software components, and another model is therefore desirable. With these discoveries taken into account, a focus on concurrency models which does not require special focus from the programmer could be of special interest for our investigation.



The landscape of Parallel Computing Research\cite{asanovic2006landscape}\\

\cite{hill2008amdahl}



\section{Models to investigate}
\andreas[inline]{Redegør for relevansen for valg af de enkelte modeller. Skriv en linie eller to i starten af hvert afsnit, om hvorfor modellen er valgt}
\lone[inline]{Forsøg at præsentere de forskellige modeller isoleret}

The purpose of this presentation is to document our preliminary concurrency model analysis, in order to justify the choice of models to analysis further. For each model a reason for looking into it will be given followed by a short description which will provide an overview of the model. Later the chosen models will be presented further in depth.\andreas[inline]{Lav en reference til den uddybende forklaring for de enkelte modeller når den er færdig}

\subsection{\acl{TL}}
The \ac{TL} model have been chosen based on its historical significance and widespread commercial use\cite[p. 58]{sutter2005software}.
The traditional \ac{TL} approach uses locks to limit the access to critical regions in order to ensure correct execution\cite[p. 1]{saha2006mcrt}.

\subsection{Actor model}
The actor model is inspired by physical laws and can be used to model, understand and reason about a wide range of concurrent systems\cite{hewitt2014actor}. The model targets both shared- and distributed-memory architectures and has support for fault tolerance\cite[Chap. 5]{sevenModels}. It is a general model for concurrency that can be used with almost any language but it is often associated with Erlang\footnote{\url{http://erlang.org}}.
 
The idea of the actor model is to use actors as the fundamental unit of computation. An actor has the following essential elements of computation\cite{actorLangNextVideo}: Processing, storage, and communication.

The actor encapsulates state and communicates with other actors by sending messages. In response to a message an actor can\cite{hewitt2014actor}:
\begin{itemize}
\item Create new actors
\item Send messages to actors it knows
\item Modify internal behavior (how the next message it receives should be handled)
\end{itemize}
Actors interact with one another through asynchronous message passing. For an actor to be able to send a message to another actor it must have the address of the actor. An actor \bscode{A} can know the address of another actor \bscode{B} if \bscode{A} creates \bscode{B} or receives the address of \bscode{B} as a message from another actor.

An actor has a mailbox which messages sent to the actor arrives in. The actor dequeues the mailbox and processes one message at a time\footnote{Not true for recursion}. Messages sent can take arbitrarily long time to arrive, and if sent concurrently can arrive in a mailbox in any order\cite{hewitt2014actor}.

The actor model avoids the deadlocks and race conditions present in the \ac{TL} model, by avoiding shared state\citep[Chap. 32]{odersky2011programming}. Instead the actor model allows isolated mutable state on actors and rely solely on asynchronous message passing between actors.



\subsection{Reactive}

Which problem does the reactive model try to solve?
\begin{itemize}
\item Nested callbacks
\end{itemize}

How does it solves it?
\begin{itemize}
\item Organization of asynchronous tasks
\item Does not care about the concurrency model underneath
\item Rx solves the issues for concurrently generating and consuming data
\item Reverse the data flow (push instead of pull)
\end{itemize}

\subsection{\acl{STM}}
\ac{STM} have been viewed by many people as a promising direction for solving concurrency issues\cite{sutter2005software}. There have been a lot of attention to this area, and there is still active research ongoing. Due to this, it is a natural candidate of interest.

\ac{STM} takes an approach to concurrency, that is based on transactions as known from database theory\cite[p. 1]{shavit1997software}. \ac{STM} transitions are atomic and isolated. Atomic meaning that either all writes in a given transaction are committed, or non of them are, while isolated means that from a given transaction \bscode{T}, any other concurrently running transaction will have no impact on the values committed by \bscode{T} when \bscode{T} succeeds\cite[p. 102]{sevenModels}. These properties are similar to the \ac{ACID} properties known from databases\cite[p. 754]{elmasri2011fundamentals}.

\ac{STM} is implemented in a number of languages, including Clojure\cite[p. 101]{sevenModels}, Concurrent Haskell\cite{harris2005composable} and Scala\cite{goodman2011muts} either directly or using a library. Generally the idea is that programmers specify regions which are to be executed as a transaction. The compiler or library then takes care of ensuring that the \ac{STM} transaction principles are maintained and that the transactions are eventually committed\cite[p. 1]{saha2006mcrt}. The transaction might be retried one or more times in the process, if any other transactions read or modified the used data.

The strength of \ac{STM} lies in the avoidance of many of the issues\lone{Nævner I dem?} that plague the traditional \ac{TL} approach. \ac{STM} can avoid deadlocks, priority inversion and eliminates the issue of balancing lock granularity vs performance\cite[p. 1]{harris2005composable}.

\subsection{Communicating Sequential Processes}

\worksheetend
