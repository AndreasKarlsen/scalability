\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Actor}{1}{April 24, 2013}{Someone}{../../}
This chapter presents the actor concurrency model by describing the key concepts in \bsref{sec:actor_concepts}. Afterwards in \bsref{sec:actor_con_issues} we present how the actor model relates to the concurrency issues presented in the \ac{TL} model. Hereafter a discussion about the actor model is presented in \bsref{sec:actor_discussion}. Finally in \bsref{sec:actor_charac} we show how the actor model fits in terms of our characteristics previously defined in \bsref{chap:char}.

\section{Key Concepts}\label{sec:actor_concepts}
The actor model is an inherently concurrent model where the main abstraction and building block is actors\cite[p. 2]{karmani2009actor}. An actor is an entity that has the following essential elements of computation\cite{actorLangNextVideo}: processing, storage, and communication. The actor is able to process instructions e.g. adding numbers together or concatenating strings. The actor is also able to store data on itself e.g. the result of some processing or some value communicated from another actor. We will explain the storage and communication elements in more detail throughout the section.

Actors are independent concurrently running entities that communicate with each other solely through asynchronous message passing\cite[p. 304]{tasharofi2013scala}. Upon receiving a message the actor examines it and determines how it will react, which can be in a number of ways\cite[p. 2]{hewitt2014actor}:
\begin{enumerate}
\item Send messages to known actors
\item Create new actors
\item Modify internal state or behaviour
\end{enumerate}
An actor can choose to react by doing one or more of the above or none if the actor is not interested in the message it receives. Additionally the actor may also do some processing.

In the first case an actor may send messages to other actors on the premise that is has the address of the actors. It is also allowed for an actor to send messages to itself. Each actor has a unique address which is represented in the actor model by a unique immutable name of an actor\cite[p. 2]{karmani2009actor}. It is then the responsibility of the chosen actor framework to map actor names to more direct addresses such as memory or network addresses, depending on implementation strategy and runtime location\cite[p. 3]{hewitt2014actor}. Addresses cannot be guessed but must be communicated. An actor \bscode{A} can know the address of another actor \bscode{B} if \bscode{A} creates \bscode{B} or receives the address of \bscode{B} as a message from an actor. Typically the exclamation mark (!) is used as the symbol to indicate sending a message. This is shown in the following example where the hello message is asynchronously sent to actor \bscode{A}:
\begin{verbatim}
A ! "hello"
\end{verbatim}

In the second case an actor can choose to create one or more new actors, the new actors will then be child actors of the creating actor. This may be attractive when an actor receives a compute intensive task as it then can create a number of new child actors and delegate the work amongst them. \bsref{fig:actor_lifecycle} presents an illustration of the life cycle of an actor. When an actor is created it is typically started also which brings the actor into an active phase. In the active phase an actor awaits messages until it retrieves a message which it will then process and upon completion the actor will again be ready to receive a new message. At some point an actor may be stopped which brings it to an inactive phase where no messages are processed and it will only go into the active phase again if it is started.

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.5]{\rootpath/worksheets/actor/figures/actor_lifecycle}
\caption{Lifecycle of an actor inspired by \cite[Figure 12]{subramaniam2011programming}}\label{fig:actor_lifecycle}
\end{figure}
In the last case an actor can choose to modify internal state or behaviour. Each actor has internal isolated state where only the actor itself is responsible and allowed to modify state. Furthermore actors have internal behaviour, typically in the form of behaviour methods, which describes how a certain type of message should be handled. For example if an actor receives an \bscode{A} message it will use the \bscode{A} behaviour method, similarly  if an actor receives a \bscode{B} message it will use the \bscode{B} behaviour method. When an actor modifies internal behaviour it will take effect for the next message to be processed. So in the third case an actor can modify internal state by updating state or change the internal behaviour by changing one or more behaviour methods.

A single actor may receive many messages in a short time period which it must be able to handle without failing. To accommodate this, each actor has an associated mailbox where messages sent to the actor is buffered in\cite[Chap. 2.6]{haller2012actors}. Messages can arrive in the mailbox at any time and it will hold the messages until the actor has processed them. An actor will retrieve one message at a time from its mailbox and process it in one atomic step\cite[p. 2]{karmani2009actor}. This reduces concurrency issues and make programs easier to reason about as multiple messages will not conflict with one another e.g. if two messages wants to update the isolated state of an actor there will be no concurrency issue in terms of race condition as only a single message will be processed at a time.\toby{Skal vi vente med at snakke om det til næste section omkring con issues?}

The arrival order of messages to an actor is non-deterministic due to the asynchronous message passing communication between actors\cite[p. 2]{karmani2011actors}. The reason for this is that messages may take arbitrary long time to arrive because of arbitrary communication de-lays on the network. The actor model assumes that messages sent are eventually received by the target actor\cite[Chap. 2.5]{haller2012actors}. However in a real system a computer may crash resulting in lost messages which means the target actor will never receive these messages which can cause starvation. It is up to the individual actor framework to adhere to the actor models principle of reliable message passing which is often accomplished through redundancy and replication\cite[Chap. 2.5]{haller2012actors}. Another reason that message arrival is non-deterministic is that there can be many concurrently running actors which may send messages in between two messages from an actor as in the following example:
\begin{verbatim}
B ! "hello"
B ! "there"
\end{verbatim}
Suppose an actor \bscode{A} sends the two messages ``hello'' and ``there'' to an actor \bscode{B}. Another concurrently running actor \bscode{C} may then send a message in-between the ``hello'' and ``there'' messages to actor \bscode{B} thereby changing the message order.

%se på nogle af fordele ved det måske (eller skal det være i diskussions afsnittet?) Evt. se hewitts artikel, hvor han har en række punkter også
%location transparency - does not have to have physical addresses of where acotrs are but only their unique addresses often in the form of Actor names. This makes it easiyer to distribute etc. etc.

\subsection{Illustration}
\bsref{fig:actor_overview} presents an illustration of the life cycle within an actor system. Each actor has an associated mailbox, isolated state and a number of behaviour methods. In the figure, actor \bscode{A} starts by sending a message to actor \bscode{B} which is stored in the mailbox associated to actor \bscode{B}. Then at some point when actor \bscode{B} is ready he retrieves the message from actor \bscode{A} from his mailbox and processes it based on which behaviour method the message corresponds to. In this case it corresponds to a behaviour method which creates a new actor, namely actor \bscode{C}. Actor \bscode{C} is now live and running with the other two actors awaiting messages. This is just a small view of what may happen in an actor system, meanwhile there may be other different actors concurrently running, sending messages, modifying isolated state and processing.

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.5]{\rootpath/worksheets/actor/figures/actor_diagram_overview}
\caption{Example of three actors. Each actor has its own mailbox, isolated state and methods. Actors responds to messages based on internal behaviour. Actor A sends Actor B a message which then creates Actor C.}\label{fig:actor_overview}
\end{figure}

\section{Concurrency issues}\label{sec:actor_con_issues}
%evt. flyt det nederst i afsnitet eller i starten af concurrency issues
%husk også ascynchonuys natur sammen med no shared state!
One of the main differences from other concurrency models, such as \ac{TL}, is that there is no notion of shared state.\toby{Skal vi lade være med at forholde os til de andre modeller i afsnittene?} Instead each actor has isolated state where only the actor itself is responsible and allowed to modify state. The reason that isolated state is preferable over shared state is that some of the concurrency issues presented earlier in \bsref{sec:tl_ci} is mitigated and some even gone. We will present which concurrency issues this affects in \bsref{sec:actor_con_issues}.
%Måske noget med nemsis of the von neumann arcitecruhe = shared store (fra gul agha original)


%Hvordan forholder det sig til concurrency issues tidligere nævnt og skaber den evt. nye concurrency problemer

%en actor processer messages i et atomic step, det afhælper concurrency issues men det kan også skade concurrency fordi hvis det kun er read operationer må de jo gerne udføres samtidigt (se JVM mastering bogen)

%event-based computation model avoids blocking waits for specific messages, which helps to keep clear of deadlocks in the system. But still able to livelock as actors can await messages from one another

\section{Discussion}\label{sec:actor_discussion}
%Cannot determine in adavance in which order messages are processed. non-deterministic
%message order is non-determinit as it may take arbitarily long time for a message to arrive in the mailbox and we must therefore make sure an actor does not depend on a speicifc message order.
	%``You can often alleviate reliance on message ordering by refactoring the actor communication, i.e., reworking the messages' contents'' - quotue actors in scala s. 34
	%Måske skal det her op i key concetps afsnittet hvis det ikke er så meget kød på det


%Evt. noget fra artiklen om at man tit anvender andre concurrency værktøjer, end kun actors artikeln (sammen med actors)

%Kritisk overfor actor modellen evt. brug "why has the actor model not succeeded"

%the argument for using actor-based programming languages is not simply that they are a good match for distributed computing platforms; it is thatActors is a goodmodel in which to think about concurrency. Actors simplify the task of programming by extending object-based design to concurrent (parallel, distributed, mobile) systems (nye blue hand book lige før biblografi)

%Måske også valg af sprog

%En disadvantage ved Actor kan være at communication overhead for høj? "Actors in scala" anden paragraf før 1.3
	%Nogle actor frameworks implementerer message passing med reference istedet for kopier, hvilket kan intoducere race conditions (fx. Scala Actors - ved ikke med Akka - undersøg det)
	
	%lightweight threads (not mapped directly to a thread - men det er vel op til den enkelte der implementere actor modellen

\section{Actor Characteristics}\label{sec:actor_charac}

\worksheetend
