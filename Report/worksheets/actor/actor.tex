\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{The Actor Model}{1}{April 24, 2013}{Tobias}{../../}
This chapter presents the actor concurrency model by describing the key concepts in \bsref{sec:actor_concepts}. Afterwards in \bsref{sec:actor_con_issues} we present how the actor model relates to the concurrency issues presented in the \ac{TL} model. Hereafter a discussion about the actor model is presented in \bsref{sec:actor_discussion}. Finally in \bsref{sec:actor_charac} we evaluate the actor model using the characteristics previously defined in \bsref{chap:char}.
\label{chap:actor}

\section{Key Concepts}\label{sec:actor_concepts}
The actor model is an inherently concurrent model where the main abstraction and building block is actors\cite[p. 2]{karmani2009actor}. An actor is an entity that has the following essential elements of computation\cite{actorLangNextVideo}: processing, storage, and communication. The actor is able to process instructions e.g. adding numbers together or concatenating strings. The actor is also able to store data on itself e.g. the result of some processing or some value communicated from another actor. We explain the storage and communication elements in more detail throughout the section.

Actors are independent concurrently running entities that communicate with each other solely through asynchronous message passing\cite[p. 304]{tasharofi2013scala}. Upon receiving a message the actor examines it and determines how it will react, which can be in a number of ways\cite[p. 2]{hewitt2014actor}:
\begin{enumerate}
\item Send messages to known actors
\item Create new actors
\item Modify internal state or behaviour
\end{enumerate}
An actor can choose to react by doing one or more of the above or none if the actor is not interested in the message it receives. Additionally the actor may also do some processing. We describe each case in more detail in the following three subsections.

\subsection{Send Messages to Known Actors}
In the first case an actor may send messages to other actors on the premise that is has the address of the actors. It is also allowed for an actor to send messages to itself. Each actor has a unique address which is represented in the actor model by a unique immutable name of an actor\cite[p. 2]{karmani2009actor}. It is then the responsibility of the chosen actor framework to map actor names to more direct addresses such as memory or network addresses, depending on implementation strategy and runtime location\cite[p. 3]{hewitt2014actor}. This facilitates location transparency which is discussed in \bsref{ssec:actor_s_properties}. Addresses cannot be guessed but must be communicated. An actor \bscode{A} can know the address of another actor \bscode{B} if \bscode{A} creates \bscode{B} or receives the address of \bscode{B} as a message from an actor. Typically the exclamation mark (!) is used as the symbol to indicate sending a message. This is shown in the following example where the hello message is sent to actor \bscode{A}:
\begin{verbatim}
A ! "hello"
\end{verbatim}

\subsection{Create New Actors}
In the second case an actor can choose to create one or more new actors, the new actors will then be child actors of the creating actor. This may be attractive when an actor receives a compute intensive task as it can create a number of new child actors and delegate the work amongst them. \bsref{fig:actor_lifecycle} presents an illustration of the life cycle of an actor. When an actor is created it is typically started also which brings the actor into an active phase. In the active phase an actor awaits messages until it receives a message which it will process and upon completion the actor will again be ready to receive a new message. At some point an actor may be stopped which brings it to an inactive phase where no messages are processed and it will only re-enter the active phase if it is started again.

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.5]{\rootpath/worksheets/actor/figures/actor_lifecycle}
\caption{Lifecycle of an actor inspired by \cite[Figure 12]{subramaniam2011programming}}\label{fig:actor_lifecycle}
\end{figure}
\subsection{Modify Internal State or Behaviour}
In the last case an actor can choose to modify internal state or behaviour. Each actor has internal isolated state where only the actor itself is responsible for and allowed to modify its state. Furthermore actors have internal behaviour, typically in the form of behaviour methods, which describes how a certain type of message should be handled. For example if an actor receives an \bscode{A} message it will use the \bscode{A} behaviour method, similarly  if an actor receives a \bscode{B} message it will use the \bscode{B} behaviour method. When an actor modifies internal behaviour it will take effect for the next message to be processed. So in the third case an actor can modify internal state by updating state or change the internal behaviour by changing one or more behaviour methods. 

\subsection{Mailbox and Message Order}\label{ssec:mailbox_and_message_order}
A single actor may receive many messages in a short time which it must be able to handle without failing. To accommodate this, each actor has an associated mailbox where messages sent to the actor are buffered\cite[Chap. 2.6]{haller2012actors}. Messages can arrive in the mailbox at any time and it will hold the messages until the actor has processed them. An actor will retrieve one message at a time from its mailbox and process it in one atomic step\cite[p. 2]{karmani2009actor}.

The arrival order of messages to an actor is non-deterministic due to the asynchronous message passing communication between actors\cite[p. 2]{karmani2011actors}. Messages may take arbitrary long time to arrive because of arbitrary communication delays on the network. The actor model assumes a notion of fairness which means that messages sent are eventually received by the target actor and no actor is starved\cite[Chap. 2.5]{haller2012actors}\cite[p. 3]{karmani2009actor}. This makes reasoning about actor programs easier\cite{tasharofi2013scala}. However, in a real system there are many reasons why a message can be lost, e.g. a computer may crash resulting in lost messages which means the target actor will never receive these messages. It is up to the individual actor framework to adhere to the actor models principle of reliable message passing, often accomplished through redundancy and replication\cite[Chap. 2.5]{haller2012actors}. Another reason that message arrival is non-deterministic is that there can be many concurrently running actors which may send messages in between two messages from an actor as in the following example:
\begin{verbatim}
B ! "hello"
B ! "there"
\end{verbatim}
Suppose an actor \bscode{A} sends the two messages ``hello'' and ``there'' to an actor \bscode{B}. Another concurrently running actor \bscode{C} may then send a message in-between the ``hello'' and ``there'' messages to actor \bscode{B} thereby changing the message order. We will talk about the implications of a non-deterministic message order later in \bsref{ssec:nondeter_msg_order}.

\subsection{Example of an Actor system}
An actor system consists of a collection of actors. \bsref{fig:actor_overview} presents an illustration of the life cycle within an actor system. Each actor has an associated mailbox, isolated state and a number of behaviour methods. Actor \bscode{A} starts by sending a message to actor \bscode{B}, stored in the mailbox associated to actor \bscode{B}. Then at some point when actor \bscode{B} is ready it retrieves the message send by actor \bscode{A} from his mailbox and processes it based on which behaviour method the message corresponds to. In this case it corresponds to a behaviour method which creates a new actor, namely actor \bscode{C}. Actor \bscode{C} is now live and running with the other two actors awaiting messages. This is just a small view of what may happen in an actor system, meanwhile there may be other different actors concurrently running, sending messages, modifying isolated state and processing.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{\rootpath/worksheets/actor/figures/actor_diagram_overview}
\caption{Example of three actors. Each actor has its own mailbox, isolated state and methods. Actors responds to messages based on internal behaviour. Actor A sends Actor B a message which then creates Actor C.}\label{fig:actor_overview}
\end{figure}

\subsection{Semantic Properties}\label{ssec:actor_s_properties}
The actor model has several important semantic properties some of which we have already covered, namely atomic processing of messages and fairness, additionally we will now look further at encapsulation and location transparency which we have only briefly described until now\cite{karmani2011actors}.

\subsubsection{Encapsulation}
Each actor must be isolated from one another, only communicating through asynchronous message passing. An actor can therefore only modify the state and behaviour methods belonging to itself. Furthermore message passing must adhere to the principle of encapsulation by not sharing state between actors, so message passing should have call by value semantics, often done by making a deep copy of the message contents\cite[p. 2]{karmani2009actor}. Encapsulation makes it easier to reason about programs modelled with the actor model\cite[p. 3]{karmani2009actor} and reduces concurrency issues which we look at in \bsref{sec:actor_con_issues}. Another benefit of encapsulation is that it eases testing of actor programs because actors can be tested in isolation. However it is on the premise that the tests must use the same types of messages and expected message order as the live environment\cite[p. 151]{sevenModels}.

\subsubsection{Location Transparency}
Actors know each other only by unique address, often in the form of an actor name, disjointed from the physical location. Location transparency provides an abstraction where the programmer does not have to worry about or specify the actual physical location of the message recipient. An actor can communicate with another actor which exists on the same core, on the same machine or on an entirely different machine across the network\cite[p. 3]{karmani2009actor}. Location transparency gives the ability at runtime to distribute execution across a cluster of machines which eases scaling beyond a single machine.

\section{Concurrency issues}\label{sec:actor_con_issues}
In this section we present how the actor model relates to the relevant concurrency issues presented in \bsref{sec:tl_ci}.\toby{Har vi også raceconditions med her hvor jeg referer til?}
%priority inversion er ikke taget med fordi den ikke er gælende i actors
%livelock er ikke med, fordi vi (mener) at den ikke er gældende

\subsection{Race conditions}
One of the main differences from other concurrency models, such as \ac{TL} and \ac{STM}, is that there is no notion of shared state in the actor model. Instead each actor has isolated state where only the actor itself is responsible and allowed to modify state. An actor can only affect the state of another actor indirectly by message passing and the receiving actor is then responsible to change the state. The reason that message passing as the only communication and isolated state is preferable over shared state is that race conditions are avoided by design. To exemplify this imagine two messages sent to an actor that wants to read and modify a state variable of the actor. The actor processes each message in one isolated atomic operation which means that the messages will not interfere with one another, as the message will be processed one at a time.
%subsec:race_coditions

\subsection{Deadlocks}
The concurrency issue of deadlocks is still a problem in the actor model. The limitation of the actor model to asynchronous message passing helps to avoid blocking waits which thereby helps to keep the program free of deadlock issues\cite[p. 304]{tasharofi2013scala}. However, asynchronous message passing introduces non-determinism which in some cases are desired to be pruned away, which we will discuss further in \bsref{ssec:nondeter_msg_order}.\toby{Fungerer denne reference?} One way to prune this non-determinism is by implementing actors by busy-waiting for the response from another actor. An example of such a busy-waiting actor program is shown in \bsref{label=lst:actor_busywait}. On line 5 there is an isolated integer state variable for the \bscode{BusyActor} while the behaviour methods are defined on lines 7-20. There are three different behaviour methods for the Start, Wait and Value messages. The actor starts by sending a message to the \bscode{OtherActor} which it desires to busy-wait for which is done by sending the \bscode{Wait} message it itself. The behaviour method for \bscode{Wait} on line 11-17 shows that the actor will print the result if it has received the result from the \bscode{OtherActor}, otherwise it will again send itself a \bscode{Wait} message. This behaviour continues until the \bscode{BusyActor} receives the \bscode{Value} message from the \bscode{OtherActor}. 

\begin{lstlisting}[label=lst:actor_busywait,
  caption={Busy-waiting actor program written in the Scala Akka actor framework.},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings}]  % Start your code-block
	
	import akka.actor._
	
	class BusyActor extends Actor {
		//State
		var result : int  = 0;
		//Behaviour methods
		def receive = {
			case Start =>
				OtherActor ! Calc
				self ! Wait
			case Wait =>
				if(result > 0){
					println(result)
				}
				else{
					self ! Wait
				}	
			case Value(i: int) =>
				result = i
		}
	}
\end{lstlisting}\toby{Hvad siger i til der kommer et kodeeksempel? Det gør det lidt lettere at forklarer læseren synes jeg}
It is possible to obtain a deadlock by two or more actors awaiting messages from one another. An illustration of a deadlock between two actors is shown \bsref{fig:actor_deadlock}.

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.5]{\rootpath/worksheets/actor/figures/actor_deadlock}
\caption{Example of a deadlock between two Actors}\label{fig:actor_deadlock}
\end{figure}

A deadlock with busy-waiting actors does however still enable other actors, unrelated to the deadlock, to send and receive messages from a deadlocked actor. This is illustrated on \bsref{fig:actor_deadlock_otheractor} where \bscode{Actor C} sends an \bscode{Other} message in-between \bscode{Actor A's} infinite busy-waiting messages. This means that even when a deadlock occurs the rest of the actor system, unrelated to the deadlock, will still be able to run.

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.5]{\rootpath/worksheets/actor/figures/actor_deadlock_otheractor}
\caption{Example of an actor C, unrelated to the deadlock, that sends a message to a deadlocked actor A. The message will will be retrived and reacted on by Actor A.}\label{fig:actor_deadlock_otheractor}
\end{figure}

%not as fatal as a deadlock in TL?
\subsection{Starvartion}
The fairness semantic property of the actor model, presented in \bsref{sec:actor_concepts}, assumes that a message sent is eventually received by the target actor and that no actor is permanently starved. This means that in the actor model there is no starvation concurrency issues.\toby{Maybe refer to adhering to actor properties subsection in discussion section, because starvation can be present in some actor implementations}
%Evt. referer til busy-wait eksmeplet i forhold til starvation
\section{Discussion}\label{sec:actor_discussion}
This section discusses a number of issues and weaknesses related to the actor model. Behaviour sharing in the actor model is discussed in \bsref{ssec:share_behaviour}, followed by a discussion of actor modelling in \bsref{ssec:actor_modelling} and lastly the non-deterministic nature of actor programs is discussed in \bsref{ssec:nondeter_msg_order}.\toby{Hvis der kommer flere sektioner, indsæt her.}

\subsection{Sharing Behaviour Among Actors}\label{ssec:share_behaviour}
Inheritance is a popular and valuable mechanism often used in object-oriented programming which allows sharing of the same behaviour inside one class across multiple classes\cite{kafura1989inheritance}. So if two classes have some common functionality, it can be written only once in a super class that they both inherit from. Sharing of behaviour avoids code duplication and code reuse which also improves maintainability as the functionality should only be maintained in a single place.

In the actor model there is no direct notion of inheritance\cite{mackay1997has}. This means that it is not possible to share behaviour among actors which hurts code reuse, maintainability and makes it more time consuming to write actor programs with common behaviour. The problem of inheritance in the actor model is that actors may change behaviour over time so it is difficult to locate or copy methods at run-time in systems without shared memory\cite{kafura1989inheritance}.\toby{kig på evt. på "inheritance in actor based concurrency object-oriented lanuages" de mener der er et mere fundamentalt problem, se afsnit "4. the actor-inheritane problem" - jeg forstår det dog ikke helt - måske en anden skal se om de kan forstå det. (de har også en mulig løsning - som dog har en limitation)}

In some specific implementations of the actor model it is possible to use inheritance in combination with actors e.g. \cite{kafura1989inheritance} presents a possible solution in their ACT++ language. However in ACT++ they do not adhere to the fundamental principle of the actor model that an actor can change behaviour over time. 

An indirect way to share behaviour among actors is to use the features of the language an actor framework is implemented in e.g. in an actor framework for Scala it is possible to use the object-oriented features such as traits to share behaviour among actors.\toby{Ved ikke om jeg bare skal lade være med at nævne dette. Jeg tænker på eksempler fra dette link: http://stackoverflow.com/questions/17383827/how-do-i-best-share-behavior-among-akka-actors}
%Måske brug den her også
%Kilde også om inheritance \cite[Chap. 1.2]{agha1986overview}

\subsection{Actor modelling}\label{ssec:actor_modelling}
One of the main properties of the actor model is that an actor processes only a single message at at time. This means that no matter what type of messages that are in the mailbox, they are processed sequentially, which can result in lower concurrency for several messages only interested in ``reading'' the internal state of an actor. Messages should be fairly coarse-grained so actors can process sufficiently many tasks concurrently without having to spend time waiting for each other\cite[p. 269]{karmani2009actor}. Furthermore as the communication is through message passing it is more attractive to have coarse-grained messages to avoid unnecessary overhead by sending a lot of small messages. However messages should not be too coarse-grained as that will hurt the dynamic among actors in the system e.g. if an actor \bscode{A} is processing a very time consuming message and another actor \bscode{B} needs a simple read of actor \bscode{A's} isolated state to continue, actor \bscode{B} must await until actor \bscode{A} is finished processing.
%Extra (the essence of it is described above i think)
	%because actors do not share state and can only communicate through message passing, they are not a suitable choice if you need fine-grained parallelism. (seven models)
	%not all applications are well-suited for an actor-based model. Actors serve well when we can divide the problem into parts that can run quite independently and need to communicate only sporadically. If frequent interaction is required or the parts or tasks need to coordinate to form a quorum, the actor-based model is not suitable. We may have to mix other concurrency models or consider significant redesign. (jvm mastering bogen)

\subsection{Non-deterministic message order}\label{ssec:nondeter_msg_order}
The asynchronous message passing is a key source to the non-determinism present in the actor model, as earlier mentioned in \bsref{ssec:mailbox_and_message_order}. That the message order is non-deterministic means that an actor must not rely on a specific message order, however according to \cite[p. 35]{haller2012actors}: \textit{``You can often alleviate reliance on message ordering by refactoring the actor communication, i.e., reworking the messages' contents''}. In some cases that do not suffice and the programmer must prune some of the non-determinism by restricting the order in which messages are processed. For example an actor \bscode{A} requests a stock quote from a broker actor \bscode{B}, then actor \bscode{A} must await the response of actor \bscode{B} to be able to decide whether to buy the stock or not. An illustration of the example is illustrated in \bsref{fig:request_reply_pattern}. The scenario described uses the request-reply pattern which is one of the most common patterns of messaging and synchronization in actor programs\cite[p. 5]{karmani2009actor}.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.6]{\rootpath/worksheets/actor/figures/request_reply_pattern}
\caption{Request-reply pattern where actor \bscode{a} blocks until it recevies the response from actor \bscode{b}. Incomming messages in the meantime is saved for later processing.}\label{fig:request_reply_pattern}
\end{figure}

To implement the request-reply pattern the programmer has to explicitly program the following steps: an actor send request, wait for reply to arrive and for each incoming message check if it is a reply to the request or another message. If the request-reply pattern is used numerous times within one program it will quickly result in unnecessary much code duplication which is why the pattern is almost universally supported as a programming abstraction in actor implementations\cite[p. 5]{karmani2009actor}.

There exists a number of other different programming abstractions for communication and synchronization in actor programs which differs depending on the choice of actor implementation\cite[p. 6]{karmani2009actor}. Another one than request-reply is local synchronization constraints which enables the programmer to postpone the processing of a message until it receives some sequence of messages or until a condition on the actors state is met.

\toby[inline]{Ved at introducere dette kan man øge chance for deadlocks. Vær sikker på det er snakket om et sted (ved ikke lige hvor det skal være endnu - muligvis i concurrency issues). Det er et tradeoff chance for deadlock og en mere let måde at udtrykke nogle bergeniner på.}

\toby[inline]{Måske put det nedenstående subsection i en subsection der hedder noget med Actor implementation discussion. Måske Implementation Specific Discussion}

\subsection{Abstraction Over Threads}\toby{Maybe also something about at some level lock acquire/release is required and it is not free - Bent's slides (coordinating message queues, locking is still required)}
The actor model provides simple constructs such as actors, mailboxes and messages to construct concurrent programs. However, these constructs is used as an abstraction that builds on top of the conventional threads and it is the responsibility of the individual actor implementation to map actors to threads. A naive solution is to map each actor onto a single thread but an actor system may consist of a large number of actors, resulting in a large overheard for thread creation and context switching\cite[p. 7]{karmani2009actor}. A more efficient solution is to have a light-weight actor to thread mapping where each actor is not directly mapped to a thread. This can be accomplished by having a fixed thread pool and using continuation based actors where the actor and its state is encapsulated in a continuation. The threads in the thread pool all share a common scheduler queue of actors. Each thread dequeues an actor from the queue and call its continuation. The thread will continue to run the actor until some condition is met e.g. there are no more messages in the actors mailbox. Light-weight actors reduces the numbers of threads which thereby reduces the overhead of thread creation, also context switches overhead is reduced by using continuations. However if the scheduling of actors is not fair it can cause starvation in the system, which is up to the individual actor implementation to ensure\cite[p. 7]{karmani2009actor}. This leads us to the next section about adherence to actor properties in actor implementations.
%light-weight actor implemetation examples: Erlang, Akka

\subsection{Adhering to Actor Properties}
As mentioned in \bsnameref{sec:prelim} there exists several actor implementations both directly as actor languages and indirectly through actor frameworks for existing languages. As the actor model is a conceptual model, it is up to the individual actor implementation to adhere to the semantic properties of the actor model, mentioned in \bsref{ssec:actor_s_properties}. Some actor implementations choose not to adhere to one or more of the actor properties as they introduce a performance overhead. In \bsref{karmani2009actor} they present a comparison of actor frameworks on the JVM platform where only half of the compared frameworks support all of the semantic properties of the actor model. 

The only form of communication in the actor model is message passing. A disadvantage of message passing is that it may produce a high communication overhead, as processes need to create and send messages, and these messages must be buffered in the mailbox before they can be received to support asynchronous message passing. Furthermore safe messaging requires call by value semantics which is often done by deep copying message contents.
%contrast shared-memory (instead reference then)
%therefore some actor implementations does not adhere to this (may mention the performance gain for actor foundry)



A potential disadvantage of message passing i

An implication of message passing  

The communication overhead 

The property of encapsulation is often broken to gain performance, specifically safe messaging is not adhered to, as it requires call by value semantics which is often done by deep copying message contents. 



%fra actors in scala:
	%potential disadvantage of message passing is that the communication overhead may be high. To communicate, processes have to create and send messages, and these messages are often buffered in queues before they can be received to support asynchronous communication.
	%By contrast, shared-state concurrency enables direct access to shared memory, as long as it is properly synchronized. To reduce the communication overhead of message passing, large messages should not be transferred by copying the message state; instead, only a reference to the message should be sent. However, this reintroduces the risk for data races when several processes have access to the same mutable (message) data. It is an ongoing research effort to provide static checkers; for instance, the Scala compiler plug-in for uniqueness types[10] that can verify that programs passing mutable messages by reference do not contain data races




 performance regards

Adhering to all of the properties can be 
%actors in scala

%break encapsulation by not ensuring safe messaging

%encapsulation example in relation to performance
	% faster performance
	%developers job to make sure instead
	%frameworks can have a problem with this as you are not prohibited to call other code from withitn an actor that can block your actor

%messages is processed in a single atomic step and , fairness, encapsulation and location transparency.

%evt. til slut i sektionen referer til jvm comparision og de kommer frem til at man godt kan have et jvm framework der understøtter alle actor properties og samitdig har "comparable" performance med andre actor frameworks der ikke gør det.

%messages can be expensive

%Kig i artiklen om jvm actor frameworks comparison og hvad de semantic properties har af implikationer på performacne og diskuter lidt overvejninger for og imod at adherede completly til actor modellen.

%%%%%%
%TRADE-OFF between adhering to actor properties and not
%performance, but also in terms of easiyer modeling your program (read following, from Why do Scala Developers Mix Actor Model with Other Con Models):
	%limitation to asynchronous message-passing helps maintain scalability and avoid data races and deadlocks, but it adds complexity to coordination.
	%event-based computation model avoids blocking waits for specific messages, which helps to keep clear of deadlocks in the system.

%breaking the actor abstraction re-introduces problems that actor semantics carefully avoid:
	%shared state between actors allows fine-grained data races and breaks transparent distribution;
	%blocking and synchronous operations can lead to deadlocks

%using actors with communication mechanisms other than asynchronous messaging is a trade-off decision
%%%%%%

%Not all actor framworks enforce all the rules of the actor model but makes that the job of the developer in some cases to improve peformance. But as it is the job of the developer now to ensure the properties of the actor model it makes til harder to write (se blue handbook actors under Semantic Properties)

%Unfortunately, actor frameworks on the JVM cannot sufficiently constrain the programming environment to avoid the concurrency pitfalls that the actor model should help you avoid. After all, within the thread you are simply writing plain old java (or scala or clojure). There’s no real way to limit what that code can do, unless it is explicitly disallowed from calling into other code or looping. Therefore, even the actor frameworks which use bytecode weaving to implement cooperative multi-tasking amongst actors cannot fully guarantee non-blocking behavior. This point bears repetition: without fundamental changes in how the JVM works, one cannot guarantee that an arbitrary piece of code will not block. fra: http://boundary.com/blog/2014/09/03/no-you-cant-have-a-pony/
%you need green threads to do this Acotrs fanciness because the native threads have too much overhead (in memory cost, creation time, etc. etc.) to be created that much
	%Istedet foreksempel erlang eller elxlir kan overholde disse kriterier.

%Some frameworks does not fulfill all the properties of the actor model to have better performance

%forskellige framworks skider på actor principperne for at forbedre performance (evt. kom ind på comaprison artiklen også.

%En disadvantage ved Actor kan være at communication overhead for høj? "Actors in scala" anden paragraf før 1.3
	%Nogle actor frameworks implementerer message passing med reference istedet for kopier, hvilket kan intoducere race conditions (fx. Scala Actors - ved ikke med Akka - undersøg det)
	
%i frameworks der ikke enforcer immutability skal udvikleren passe på ikke at komme til at kalde behaviour metoder der er isoleret inde i actors og sikre messages er immutable, så man ikke sharer state.
	%Kom med eksemplet om en counter. (fra comparative jvm artiklen)
	%In languages that do not enfore call-by-value semantics in we must be sure not to break state encapsulation.

\toby[inline]{Message passing overhead}

	
%EKSTRA:

%ekstra kilde(http://www.erlang-factory.com/upload/presentations/756/taking-back-embedded-factory_sf_2013.pdf):
%No notion of inheritance or general hierarchy
	%Specific to language and library implementation
%Asynchronous message passing can be  problematic for certain applications
	%Ordering of messages received from multiple processes
	%Abstract definition may lead to inconsistency in larger systems
		%Fine/Coarse Grain argument 

%Why has the actor model not succeeded yet:
%One of the key features of actors, their ability to create other actors as part of their behaviour, has the potential to dramatically change the state of the system at any particular time. The decisions of where to store and execute newly created actors is important to overall performance, and will require records to be kept of what is executing and where.
	%In at distributed setting involing different locations can affect performance if communication is acorss the remote locations many times if they could be optimized and be local
	%The behaviour methods of an actor is dynamic and can be changed at runtime - which makes optimisation f.x. compiler optimisations hard. However in some implementations you must write the different behvaiour methods beforehand
	%Asynchronous message passing can cause problems for certain problems
		%For example, manipulation of a stack-like structure using asynchronous message passing could be problematic if the messages do not arrive in the correct order
		%Men som anden kilde siger så kan man tit komme udenom dette problem ved at remodellere sine actors
	
%unbounded mailboxes 
	%implies some form of infinite stack or pointer structure, but it cannot be assumed that this is available in all architectures
%node failue in the system can lead to problems starvation

%8.13 s. 269 Limitations of the Actor-Based Model i JVM Mastering syncrhonization

%actors provide no direct support for parallelism. Parallel solutions need to be built from concurrent building blocks, raising the specter of nondeterminism. And because actors do not share state and can only communicate through message passing, they are not a suitable choice if you need fine-grained parallelism.

%Cannot determine in adavance in which order messages are processed. non-deterministic - can be hard to grasp at first

%the argument for using actor-based programming languages is not simply that they are a good match for distributed computing platforms; it is that Actors is a goodmodel in which to think about concurrency. Actors simplify the task of programming by extending object-based design to concurrent (parallel, distributed, mobile) systems (nye blue hand book lige før biblografi)

%Actors simplify the task of programming by extending object-based design to concurrent (parallel, distributed, mobile) systems.

%pga. message passing = dyrt at kopiere messages rundt and can only procees one message at a time

	
\toby[inline]{Overflow of an actor's mailbox}
%actors are still susceptible to problems like deadlock plus a few failure modes unique to actors (such as overflowing an actor’s mailbox).

\toby[inline]{Evt. også hav en subsektion hvor der fortælles om at actor modellen tit blandes med andre concurrency modeller (tag udgangspunkt i den artikel i droppen)}
%Noget fra artiklen om at man tit anvender andre concurrency værktøjer, end kun actors artikeln (sammen med actors).
	%bl.a. actor model og libray inadequecies og evt. også konklussionen
	
%%%EXTRA%%%

%actors in scala p. 15:
%potential disadvantage of message passing is that the communication overhead may be high. To communicate, processes have to create and send messages, and these messages are often buffered in queues before they can be received to support asynchronous communication

%Free of data races but still possible to have deadlocks and also problems only related to actors fx. Overflowing of an actors mailbox (seven models 152)

%Seven models p. 152 weaknesses
%Although a program constructed with actors is easier to debug than one constructed with threads and locks, actors are still susceptible to problems like deadlock plus a few failure modes unique to actors (such as overflowing an actor’s mailbox).

\section{Actor Characteristics}\label{sec:actor_charac}

% since an actor can only respond to a single message at a time you get implicit locking around all of the local state for that actor.

\worksheetend
