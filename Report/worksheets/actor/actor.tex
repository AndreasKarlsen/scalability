\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{The Actor Model}{1}{April 24, 2013}{Tobias}{../../}
This chapter presents the actor concurrency model by describing its key concepts in \bsref{sec:actor_concepts}. Afterwards in \bsref{sec:actor_con_issues} we present how the actor model relates to the concurrency issues presented in the \ac{TL} model. Hereafter a discussion about the actor model is presented in \bsref{sec:actor_discussion}. Finally in \bsref{sec:actor_charac} we evaluate the actor model using the characteristics previously defined in \bsref{chap:char}.
\label{chap:actor}

\section{Key Concepts}\label{sec:actor_concepts}
The actor model is an inherently concurrent model where the main abstraction and building block is actors\cite[p. 2]{karmani2009actor}. An actor is an entity that has the following essential elements of computation\cite{actorLangNextVideo}:
\begin{inparaenum}[(1)]
\item processing
\item storage and
\item communication.
\end{inparaenum} 
A actor is able to process instructions e.g. adding numbers together or concatenating strings. The actor is also able to store data on itself e.g. the result of some processing or some value communicated from another actor. We explain the storage and communication elements in more detail throughout the section.

Actors are independent concurrently running entities that communicate with each other solely through asynchronous message passing\cite[p. 304]{tasharofi2013scala}. Upon receiving a message the actor examines it and determines how it will react, which can be in a number of ways\cite[p. 2]{hewitt2014actor}:
\begin{enumerate}
\item Send messages to known actors
\item Create new actors
\item Modify internal state or behaviour
\end{enumerate}
An actor can choose to react by doing one or more of the above or none if the actor is not interested in the message it receives. Additionally the actor may also do some processing. We describe each case in more detail in the following three subsections.

\subsection{Send Messages to Known Actors}
In the first case an actor may send messages to other actors on the premise that is has the address of the actors. It is also allowed for an actor to send messages to itself. Each actor has a unique address which is represented in the actor model by a unique immutable name of an actor\cite[p. 2]{karmani2009actor}. It is then the responsibility of the chosen actor framework to map actor names to more direct addresses such as memory or network addresses, depending on implementation strategy and runtime location\cite[p. 3]{hewitt2014actor}. This facilitates location transparency which is discussed in \bsref{ssec:actor_s_properties}. Addresses cannot be guessed but must be communicated. An actor \bscode{A} can know the address of another actor \bscode{B} only if \bscode{A} creates \bscode{B} or receives the address of \bscode{B} as a message from another actor. Typically the exclamation mark (!) is used as the symbol to indicate sending a message. This is shown in the following example where the hello message is sent to actor \bscode{A}:
\begin{verbatim}
A ! "hello"
\end{verbatim}

\subsection{Create New Actors}
In the second case an actor can choose to create one or more new actors, the new actors will then be child actors of the creating actor. This may be attractive when an actor receives a compute intensive task as it can create a number of new child actors and delegate the work amongst them. \bsref{fig:actor_lifecycle} presents an illustration of the life cycle of an actor. When an actor is created it is typically started also which brings the actor into an active phase. In the active phase an actor awaits messages until it receives a message to process. Upon processing completion the actor will again be ready to receive a new message. At some point an actor may be stopped which brings it to an inactive phase where no messages are processed and it will only re-enter the active phase if it is started again.

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.5]{\rootpath/worksheets/actor/figures/actor_lifecycle}
\caption{Lifecycle of an actor inspired by \cite[Figure 12]{subramaniam2011programming}}\label{fig:actor_lifecycle}
\end{figure}
\subsection{Modify Internal State or Behaviour}
In the last case an actor can choose to modify internal state or behaviour. Each actor has internal isolated state where only the actor itself is responsible for and allowed to modify its state. Furthermore actors have internal behaviour, typically in the form of behaviour methods, which describes how a certain type of message should be handled. For example if an actor receives an \bscode{A} message it will use the \bscode{A} behaviour method, similarly  if an actor receives a \bscode{B} message it will use the \bscode{B} behaviour method. When an actor modifies internal behaviour it will take effect for the next message to be processed. So in the third case an actor can modify internal state by updating state or change the internal behaviour by changing one or more behaviour methods. 

\subsection{Mailbox and Message Order}\label{ssec:mailbox_and_message_order}
A single actor may receive many messages in a short time which it must be able to handle without failing. To accommodate this, each actor has an associated mailbox where messages sent to the actor are buffered\cite[Chap. 2.6]{haller2012actors}. Messages can arrive in the mailbox at any time and it will hold the messages until the actor has processed them. An actor will retrieve one message at a time from its mailbox and process it in one atomic step\cite[p. 2]{karmani2009actor}.

The arrival order of messages to an actor is non-deterministic due to the asynchronous message passing between actors\cite[p. 2]{karmani2011actors}. Messages may take arbitrary long time to arrive because of arbitrary communication delays on the network. The actor model assumes a notion of fairness which means that messages sent are eventually received by the target actor and no actor is starved\cite[Chap. 2.5]{haller2012actors}\cite[p. 3]{karmani2009actor}. This makes reasoning about actor programs easier\cite{tasharofi2013scala}. However, in a real system there are many reasons why a message can be lost, e.g. a computer may crash resulting in lost messages which means the target actor will never receive these messages. It is up to the individual actor framework to adhere to the actor models principle of reliable message passing, often accomplished through redundancy and replication\cite[Chap. 2.5]{haller2012actors}. Another reason that message arrival is non-deterministic is that there can be many concurrently running actors which may send messages in between two messages from an actor as in the following example:
\begin{verbatim}
B ! "hello"
B ! "there"
\end{verbatim}
Suppose an actor \bscode{A} sends the two messages ``hello'' and ``there'' to an actor \bscode{B}. Another concurrently running actor \bscode{C} may then send a message in-between the ``hello'' and ``there'' messages to actor \bscode{B} thereby changing the message order. We will talk about the implications of a non-deterministic message order later in \bsref{ssec:nondeter_msg_order}.

\subsection{Example of an Actor system}
An actor system consists of a collection of actors. \bsref{fig:actor_overview} presents an illustration of the life cycle within an actor system. Each actor has an associated mailbox, isolated state and a number of behaviour methods. Actor \bscode{A} starts by sending a message to actor \bscode{B}, stored in the mailbox associated to actor \bscode{B}. Then at some point when actor \bscode{B} is ready it retrieves the message send by actor \bscode{A} from its mailbox and processes it based on which behaviour method the message corresponds to. In this case it corresponds to a behaviour method which creates a new actor, namely actor \bscode{C}. Actor \bscode{C} is now live and running with the other two actors awaiting messages. This is just a small view of what may happen in an actor system, meanwhile there may be other actors running concurrently, sending messages, modifying isolated state and creating new actors.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{\rootpath/worksheets/actor/figures/actor_diagram_overview}
\caption{Example of three actors. Each actor has its own mailbox, isolated state and methods. Actors responds to messages based on internal behaviour. Actor A sends Actor B a message which then creates Actor C.}\label{fig:actor_overview}
\end{figure}

\subsection{Semantic Properties}\label{ssec:actor_s_properties}
The actor model has several important semantic properties some of which we have already covered, namely atomic processing of messages and fairness, additionally we will now look further at encapsulation and location transparency which we have only briefly described until now\cite{karmani2011actors}.

\subsubsection{Encapsulation}
Each actor must be isolated from one another, only allowing communicating through asynchronous message passing. An actor can therefore only modify the state and behaviour methods belonging to itself. Furthermore message passing must adhere to the principle of encapsulation by not sharing state between actors, so message passing should have call by value semantics, often done by making a deep copy of the message contents\cite[p. 2]{karmani2009actor}. Encapsulation makes it easier to reason about programs modelled with the actor model\cite[p. 3]{karmani2009actor} and reduces concurrency issues which we look at in \bsref{sec:actor_con_issues}. Another benefit of encapsulation is that it eases testing of actor programs because actors can be tested in isolation. However it is on the premise that the tests must use the same types of messages and expected message order as the live environment\cite[p. 151]{sevenModels}.

\subsubsection{Location Transparency}
Actors know each other only by a unique address, often in the form of an actor name, disjointed from the physical location. Location transparency provides an abstraction where the programmer does not have to worry about or specify the actual physical location of the message recipient. An actor can communicate with another actor which exists on the same core, on the same machine or on an entirely different machine across the network using the same approach\cite[p. 3]{karmani2009actor}. Location transparency gives the ability to distribute execution across a cluster of machines at runtime, which eases scaling beyond a single machine.

\section{Concurrency Issues}\label{sec:actor_con_issues}
In this section we present how the actor model relates to the relevant concurrency issues presented in \bsref{subsec:race_coditions} and \bsref{sec:tl_ci}.
%priority inversion er ikke taget med fordi den ikke er gælende i actors
%livelock er ikke med, fordi vi (mener) at den ikke er gældende

\subsection{Race Conditions}
One of the main differences from other selected concurrency models, such as \ac{TL} and \ac{STM}, is that there is no notion of shared state in the actor model. Instead each actor has isolated state where only the actor itself is responsible and allowed to modify state. An actor can only affect the state of another actor indirectly by message passing and the receiving actor is then responsible for changing the state. Employing message passing as the only means of communication as well as isolated state is preferable over shared state as that race conditions are avoided by design. To exemplify this imagine two messages sent to an actor that wants to read and modify a state variable of the actor. The actor processes each message in one isolated atomic operation which means that the messages will not interfere with one another, as the messages will be processed one at a time.
%subsec:race_coditionsa 

\subsection{Cyclic Dependencies}
\label{sec:actor_cyclic_dependency}
Cyclic Dependencies can be produced using the actor model. A simple example is shown in \bsref{fig:actor_cyclic}.

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.5]{\rootpath/worksheets/actor/figures/actor_deadlock}
\caption{Example of a clyclic dependencies between two Actors}\label{fig:actor_cyclic}
\end{figure}

Actor \bscode{A} sends messages to actor \bscode{B} which sends messages to actor \bscode{A}. As such message \bscode{A} depends on messages from actor \bscode{B} and \bscode{B} depends on messages from actor \bscode{A}. 

A consequence of cyclic dependencies between actors is livelocks. If the actors \bscode{A} and \bscode{B} are performing computations that are dependent upon one another then actor \bscode{A} may send a messages to \bscode{B} requesting it to returns the result of its computation. Actor \bscode{B} may then send a messages to actor \bscode{A} requesting the result of its computation as it is required in order to complete actors \bscode{B}'s computation creating a livelock, where this process will continue until resolved. In a larger actor system the livelock may be less apparent as many actors may be involved in a cyclic dependency.

Actors part of a cyclic dependency can still process messages not part of the dependency. If actor \bscode{A} is able to process other types of messages than those send by actor \bscode{B} then these messages can continue to be processed as is the only the cyclic dependant computation which becomes livelocked and not the actors. Consider the example presented in \bsref{fig:actor_cyclic2}.

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.5]{\rootpath/worksheets/actor/figures/actor_cylic2}
\caption{Example of a messages proccessing in clyclic dependency}\label{fig:actor_cyclic2}
\end{figure}

While the computation between actors \bscode{A} and \bscode{B} is running actor \bscode{A} receives a messages from actor \bscode{C}. Since actor \bscode{A} keeps processing messages from its mailbox the messages from actor \bscode{C} will eventually be processed.

%\subsection{Deadlock}\label{ssec:actor_deadlock}
%The concurrency issue of deadlocks is still a problem in the actor model. The actor model limits the communication to asynchronous message passing only. This helps avoid blocking waits which thereby helps to keep the program free of deadlocks\cite[p. 304]{tasharofi2013scala}. However, asynchronous message passing introduces non-determinism which in some cases is undesirable e.g. an actor buying stocks would like to know the stock quote from an actor broker before deciding whether to buy a stock or not. We will discuss non-deterministic message order further in \bsref{ssec:nondeter_msg_order}. One way to prune this non-determinism is by implementing actors by busy-waiting for the response from another actor. An example of such a busy-waiting actor program is shown in \bsref{lst:actor_busywait}. On line 5 there is an isolated integer state variable for the \bscode{BusyActor} while the behaviour methods are defined on lines 7-20. There are three different behaviour methods for the Start, Wait and Value messages. The \bscode{BusyActor} desires to busy-wait for the \bscode{OtherActor} which it does by sending 
%
%The \bscode{BusyActor} starts by sending a message to the \bscode{OtherActor} and starts the busy-waiting by sending the \bscode{Wait} message to itself. The behaviour method for \bscode{Wait} on line 11-17 shows that the actor will print the result if it has received the result from the \bscode{OtherActor}, otherwise it will again send itself a \bscode{Wait} message. This behaviour continues until the \bscode{BusyActor} receives the \bscode{Value} message from the \bscode{OtherActor}. 
%
%\begin{lstlisting}[label=lst:actor_busywait,
%  caption={Busy-waiting actor program written in the Scala Akka actor framework.},
%  language=Scala,  
%  showspaces=false,
%  showtabs=false,
%  breaklines=true,
%  showstringspaces=false,
%  breakatwhitespace=true,
%  commentstyle=\color{greencomments},
%  keywordstyle=\color{bluekeywords},
%  stringstyle=\color{redstrings}]  % Start your code-block
%	
%	import akka.actor._
%	
%	class BusyActor extends Actor {
%		//State
%		var result : int  = 0;
%		//Behaviour methods
%		def receive = {
%			case Start =>
%				OtherActor ! Calc
%				self ! Wait
%			case Wait =>
%				if(result > 0){
%					println(result)
%				}
%				else{
%					self ! Wait
%				}	
%			case Value(i: int) =>
%				result = i
%		}
%	}
%\end{lstlisting}
%It is possible to obtain a deadlock by two or more actors awaiting messages from one another. An illustration of a deadlock between two actors is shown \bsref{fig:actor_deadlock}.
%
%\begin{figure}[ht!]
%\centering
%\includegraphics[scale=0.5]{\rootpath/worksheets/actor/figures/actor_deadlock}
%\caption{Example of a deadlock between two Actors}\label{fig:actor_deadlock}
%\end{figure}
%
%A deadlock with busy-waiting actors does however still enable other actors, unrelated to the deadlock, to send and receive messages to and from a deadlocked actor. This is illustrated on \bsref{fig:actor_deadlock_otheractor} where \bscode{Actor C} sends an \bscode{Other} message in-between \bscode{Actor A's} infinite busy-waiting messages. This means that even when a deadlock occurs the rest of the actor system, unrelated to the deadlock, will still be able to run.
%
%\begin{figure}[ht!]
%\centering
%\includegraphics[scale=0.5]{\rootpath/worksheets/actor/figures/actor_deadlock_otheractor}
%\caption{Example of an actor C, unrelated to the deadlock, that sends a message to a deadlocked actor A. The message will will be retrived and reacted on by Actor A.}\label{fig:actor_deadlock_otheractor}
%\end{figure}

%not as fatal as a deadlock in TL?
\subsection{Starvartion}
The fairness semantic property of the actor model, presented in \bsref{sec:actor_concepts}, assumes that a message sent is eventually received by the target actor and that no actor is permanently starved. This means that in the actor model there is no starvation concurrency issues. However in some actor implementations starvation is present, one reason is that it may not be possible to adhere to the fairness property in an actor framework for an existing language. We will discuss more about adhering to actor properties in \bsref{ssec:adhere_actor_prop}.

Consider the example of the busy-waiting actor program, potentially causing starvation, shown in \bsref{lst:actor_busywait}. On line 5 there is an isolated integer state variable for the \bscode{BusyActor} while the behaviour methods are defined on lines 7-20. There are three different behaviour methods for the Start, Wait and Value messages. The \bscode{BusyActor} desires to busy-wait for the \bscode{OtherActor} which it does by sending 

The \bscode{BusyActor} starts by sending a message to the \bscode{OtherActor} and starts the busy-waiting by sending the \bscode{Wait} message to itself. The behaviour method for \bscode{Wait} on line 11-17 shows that the actor will print the result if it has received the result from the \bscode{OtherActor}, otherwise it will again send itself a \bscode{Wait} message. This behaviour continues until the \bscode{BusyActor} receives the \bscode{Value} message from the \bscode{OtherActor}. 

\begin{lstlisting}[label=lst:actor_busywait,
  caption={Busy-waiting actor program written in the Scala Akka actor framework.},
  language=Scala,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings}]  % Start your code-block
	
	import akka.actor._
	
	class BusyActor extends Actor {
		//State
		var result : int  = 0;
		//Behaviour methods
		def receive = {
			case Start =>
				OtherActor ! Calc
				self ! Wait
			case Wait =>
				if(result > 0){
					println(result)
				}
				else{
					self ! Wait
				}	
			case Value(i: int) =>
				result = i
		}
	}
\end{lstlisting}

The busy waiting actor presented in \bsref{lst:actor_busywait} presents a possible cause of starvation in actor systems not adhering to the fairness property. By sending wait messages to it self the \bscode{BusyActor} may occupy a native thread. In the absence of fairness the \bscode{OtherActor} may never be scheduled and thereby starved. In such a scenario the actor \bscode{BusyActor} is regarded as a non-cooperative actor eg. the cause of starvation\cite{karmani2009actor}.
%Evt. referer til busy-wait eksmeplet og forklar hvordan det er muligt at have starvation deri
\section{Discussion}\label{sec:actor_discussion}
This section discusses a number of issues and weaknesses related to the actor model. Behaviour sharing in the actor model is discussed in \bsref{ssec:share_behaviour}, followed by a discussion of actor modelling in \bsref{ssec:actor_modelling}. Hereafter we look at the non-deterministic message order present in the actor model in \bsref{ssec:nondeter_msg_order}. The last two sections are more actor implementation oriented where we first in \bsref{ssec:abstraction_over_threads} describe the relation between actors and threads and lastly in \bsref{ssec:adhere_actor_prop} discuss adherence to actor properties in actor implementations.

\subsection{Sharing Behaviour Among Actors}\label{ssec:share_behaviour}
Inheritance is a popular and valuable mechanism often used in \ac{OOP} which allows sharing of the same behaviour inside one class across multiple classes\cite{kafura1989inheritance}. So if two classes have some common functionality, it can be written only once in a super class that they both inherit from. Sharing of behaviour avoids code duplication and code reuse which also improves maintainability as the functionality should only be maintained in a single place.

In the actor model there is no direct notion of inheritance\cite{mackay1997has}. This means that it is not possible to share behaviour among actors which hurts code reuse, maintainability and makes it more time consuming to write actor programs with common behaviour. The problem of inheritance in the actor model is that actors may change behaviour over time so it is difficult to locate or copy methods at run-time in systems without shared memory\cite{kafura1989inheritance}.

In some specific implementations of the actor model it is possible to use inheritance in combination with actors e.g. \cite{kafura1989inheritance} presents a possible solution in their ACT++ language. However in ACT++ they do not adhere to the fundamental principle of the actor model that an actor can change behaviour over time. 

An indirect way to share behaviour among actors is to use the features of the language an actor framework is implemented in e.g. in an actor framework for Scala it is possible to use the object-oriented features such as traits to share behaviour among actors. Another option is to rely on delegation instead of inheritance.
%Måske brug den her også
%Kilde også om inheritance \cite[Chap. 1.2]{agha1986overview}

\subsection{Actor Modelling}\label{ssec:actor_modelling}
One of the main properties of the actor model is that an actor processes only a single message at at time. This means that no matter what type of messages that are in the mailbox, they are processed sequentially, which can result in a lower degree of concurrency for several messages only interested in ``reading'' the internal state of an actor. Messages should be fairly coarse-grained so actors can process sufficiently many tasks concurrently without having to spend time waiting for each other\cite[p. 269]{karmani2009actor}. Furthermore as the communication is through message passing it is more attractive to have coarse-grained messages to avoid unnecessary overhead by sending a lot of small messages. However messages should not be too coarse-grained as that will hurt the dynamics among actors in the system e.g. if an actor \bscode{A} is processing a very time consuming message and another actor \bscode{B} needs a simple read of actor \bscode{A's} isolated state to continue, actor \bscode{B} must await until actor \bscode{A} is finished processing.
%Extra (the essence of it is described above i think)
	%because actors do not share state and can only communicate through message passing, they are not a suitable choice if you need fine-grained parallelism. (seven models)
	%not all applications are well-suited for an actor-based model. Actors serve well when we can divide the problem into parts that can run quite independently and need to communicate only sporadically. If frequent interaction is required or the parts or tasks need to coordinate to form a quorum, the actor-based model is not suitable. We may have to mix other concurrency models or consider significant redesign. (jvm mastering bogen)

\subsection{Non-deterministic Message Order}\label{ssec:nondeter_msg_order}
The asynchronous message passing is a key source of non-determinism in the actor model, as mentioned earlier in \bsref{ssec:mailbox_and_message_order}. That the message order is non-deterministic means that an actor must not rely on a specific message order, however according to \cite[p. 35]{haller2012actors}: \textit{``You can often alleviate reliance on message ordering by refactoring the actor communication, i.e., reworking the messages' contents''}. In some cases that does not suffice and the programmer must prune some of the non-determinism by restricting the order in which messages are processed. For example an actor \bscode{A} requests a stock quote from a broker actor \bscode{B}, then actor \bscode{A} must await the response of actor \bscode{B} to be able to decide whether to buy the stock or not. An illustration of the example is illustrated in \bsref{fig:request_reply_pattern}. The scenario described uses the request-reply pattern which is one of the most common patterns of messaging and synchronization in actor programs\cite[p. 5]{karmani2009actor}.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.6]{\rootpath/worksheets/actor/figures/request_reply_pattern}
\caption{Request-reply pattern where actor \bscode{A} blocks until it recevies the response from actor \bscode{B}. Other messages received while blocking is saved for later processing.}\label{fig:request_reply_pattern}
\end{figure}

To implement the request-reply pattern the programmer has to explicitly program the following steps: an actor send request, wait for reply to arrive and for each incoming message check if it is a reply to the request or another message. If the request-reply pattern is used numerous times within one program it will quickly result in unnecessary code duplication which is why the pattern is almost universally supported as a programming abstraction in actor implementations\cite[p. 5]{karmani2009actor}.

The request reply pattern can lead to deadlocks as no other messages are processed while a actor waits on the reply. Consider the example presented in \bsref{fig:actor_deadlock_request_reply}.

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.5]{\rootpath/worksheets/actor/figures/actor_deadlock}
\caption{Example of a request reply deadlock}\label{fig:actor_deadlock_request_reply}
\end{figure}

Actor \bscode{A} sends a message to actor \bscode{B} and waits for the reply. In response actor \bscode{B} sends a messages to \bscode{A} and waits for the reply. As neither actor can now process any other messages than the expected replies a deadlock is created. The deadlock does not have to be directly between two actors. Instead the deadlock can be the result of actor \bscode{A} sending a request-reply to some actor which eventually results in actor \bscode{B} receiving a messages and sending a request reply messages to actor \bscode{A}. As actor run concurrently a deadlock can even arise from actors \bscode{C} and \bscode{D} sending a request reply messages to one another, either directly or indirectly, as a result of two unconnected computations.

There exists a number of other different programming abstractions for communication and synchronization in actor programs which differ depending on the choice of actor implementation\cite[p. 6]{karmani2009actor}. An alternative to request-reply is local synchronization constraints which enables the programmer to postpone the processing of a message until it receives some sequence of messages or until a condition on the actors state is met.

However pruning the non-deterministic nature of asynchronous message passing in the actor model is not without implications. If the communication is restricted to blocking and synchronous operations it can lead to deadlocks, as described previously. The limitation to asynchronous message passing helps avoid deadlocks but it adds to the complexity of coordination\cite[p. 311]{tasharofi2013scala}.

\subsection{Abstraction Over Threads}\label{ssec:abstraction_over_threads}
The actor model provides simple constructs such as actors, mailboxes and messages to construct concurrent programs. However, these constructs are used as an abstraction that builds on top of the conventional threads and it is the responsibility of the individual actor implementation to map actors to threads. A naive solution is to map each actor onto a single thread but an actor system may consist of a large number of actors, resulting in a large overhead for thread creation and context switching\cite[p. 7]{karmani2009actor}. A more efficient solution is to have a light-weight actor to thread mapping where each actor is not directly mapped to a thread. This can be accomplished by having a fixed thread pool and using continuation based actors where the actor and its state is encapsulated in a continuation. The threads in the thread pool all share a common scheduler queue of actors. Each thread dequeues an actor from the queue and calls its continuation. The thread will continue to run the actor until some condition is met e.g. there are no more messages in the actors mailbox. Light-weight actors reduce the number of threads which thereby reduces the overhead of thread creation, also context switch overhead is reduced by using continuations. However if the scheduling of actors is not fair it can cause starvation in the system\cite{karmani2009actor}. It is the responsibility of the individual actor implementation to ensure the semantic property of fairness and thereby avoid starvation. This leads us to the next section about adherence to actor properties in actor implementations.
%light-weight actor implemetation examples: Erlang, Akka

\subsection{Adhering to Actor Properties}\label{ssec:adhere_actor_prop}
As mentioned in \bsnameref{sec:prelim} there exist several actor implementations both directly as actor languages and indirectly through actor frameworks for existing languages. As the actor model is a conceptual model, it is up to the individual actor implementation to adhere to the semantic properties of the actor model, mentioned in \bsref{ssec:actor_s_properties}. Some actor implementations choose not to adhere to one or more of the actor properties as they introduce a performance overhead. In \cite{karmani2009actor} they present a comparison of actor frameworks on the JVM platform where only half of the compared frameworks support all of the semantic properties of the actor model. 

\subsubsection{Safe Message Passing}\label{sssec:safe_msg_passing}
The only form of communication in the actor model is message passing. A disadvantage of message passing is that it may produce a high communication overhead, because processes need to create and send messages, and these must be buffered in the mailbox before they can be received to support asynchronous message passing\cite[p. 17]{haller2012actors}. Furthermore, safe messaging requires call by value semantics which often involves deep copying message contents, which is an expensive operation for large messages. To reduce the overhead of message passing, some actor implementations chooses to implement message passing by sending message contents by reference opposed to deep copying message contents.\toby{Skal vi have eksempler på nogle der gør det? Akka og Kilim gør det f.eks.} However, this reintroduces the concurrency issue of race conditions, as multiple actors can have access to the same shared memory directly through the reference. For example one actor may use the reference inside a message to change the state of another actor directly, opposed to only being able to do it indirectly through a message as the conceptual actor model states. The actor implementations that send message contents by reference put the responsibility of ensuring safe messaging on the programmers, which can be done e.g. by using immutable messages or less strictly, simply not changing any message contents. It is often a trade-off between performance and adhering to all the semantic properties of the actor model, in that you loose some of the advantages of using the actor model by getting a performance gain.
%another way for developers to manually handle it is to deep copy message contents which may be modified and refernece others (for example large messages)
%Akka can’t enforce message immutability (yet) so this has to be by convention. (http://doc.akka.io/docs/akka/snapshot/java/untyped-actors.html)

\subsubsection{Unbounded Mailbox}\label{sssec:unbounded_mail}
In the conceptual actor model the mailbox is unbounded, meaning that it is possible to store infinitely many messages in an actors mailbox. However, in an actual actor implementation there exists an upper limit on how many messages that can be stored based on how much physical storage is available. The consequence of an upper limit of messages in a mailbox is that it makes it possible to overflow the mailbox which can cause the system to crash\cite[p. 152]{sevenModels}.

\subsubsection{Actor Framework Limitations}
An actor framework for an existing language is more limited than an actor based language, as doing program transformations, compilation and runtime optimizations to gain better performance is less challenging\cite[p. 5]{karmani2011actors}. Another disadvantage of an actor framework in an existing language is that you are writing normal code from the existing language within you actors, which may not constrain the programming environment sufficiently to support the actor model. An example of this can be seen in \bsref{lst:actor_state_encapsulation_violation} which shows how it is possible in the Scala Actors framework to break the encapsulation property of the actor model. On line 3-12 the \bscode{CountActor} actor is defined which has a behaviour method for when it receives an \bscode{enter} message which will increment the state variable \bscode{num} if \bscode{MAX} has not been reached. On line 14-19 a main function is defined which creates \bscode{myCount} and starts it. On line 17 an \bscode{enter} message is sent to \bscode{myCount} but on line 18 behaviour method for \bscode{enter} is called directly because the \bscode{Actor} is simply a class, so it is possible to call the methods within a class in Scala. The encapsulation property of the actor model is broken because an actor must only be able to execute the behaviour method of another actor indirectly through a message and not directly. In this case it may cause two actors to simultaneously execute the \bscode{enter} method which can lead to race conditions. 

\begin{lstlisting}[label=lst:actor_state_encapsulation_violation,
  caption={Scala Actors violating state encapsulation},
  language=Scala,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings}]  % Start your code-block
	
	import scala.Actors.Actor
	
	class CountActor() extends Actor {
				
		...
		
		def enter(){
			if(num < MAX){
				num = num + 1;
			}
		}
	}
	
	def main(args : Array[String]) : Unit = {
		var myCount = new CountActor();
		myCount.start
		myCount ! "enter"
		myCount.enter
	}
\end{lstlisting}

The programmer may therefore have to be observant not to violate the semantic properties of the actor model by mistake, when using an actor framework for an existing language.

%evt. til slut i sektionen referer til jvm comparision og de kommer frem til at man godt kan have et jvm framework der understøtter alle actor properties og samitdig har "comparable" performance med andre actor frameworks der ikke gør det.

%Unfortunately, actor frameworks on the JVM cannot sufficiently constrain the programming environment to avoid the concurrency pitfalls that the actor model should help you avoid. After all, within the thread you are simply writing plain old java (or scala or clojure). There’s no real way to limit what that code can do, unless it is explicitly disallowed from calling into other code or looping. Therefore, even the actor frameworks which use bytecode weaving to implement cooperative multi-tasking amongst actors cannot fully guarantee non-blocking behavior. This point bears repetition: without fundamental changes in how the JVM works, one cannot guarantee that an arbitrary piece of code will not block. fra: http://boundary.com/blog/2014/09/03/no-you-cant-have-a-pony/

%Noget fra artiklen om at man tit anvender andre concurrency værktøjer, end kun actors artikeln (sammen med actors).
	%bl.a. actor model og libray inadequecies og evt. også konklussionen

%EKSTRA:
	%the argument for using actor-based programming languages is not simply that they are a good match for distributed computing platforms; it is that Actors is a goodmodel in which to think about concurrency. Actors simplify the task of programming by extending object-based design to concurrent (parallel, distributed, mobile) systems (nye blue hand book lige før biblografi)
\section{Actor Model Characteristics}\label{sec:actor_charac}
This section presents how the actor model relates to the selected characteristics presented in \bsref{chap:char}.

\subsection{Implicit or Explicit Concurrency}
The actor model hides the low level concepts of threads and locking. While it builds upon them, they are implicitly handled by the actor system. The actor model does however expose a number of new constructs in the form of creating actors, sending messages and modifying isolated state or behaviour. These must be explicitly handled by the programmer. Concurrency is introduced by creating actors and communication is done explicitly by sending messages. As such we say that the actor model is an explicit concurrency model. This is shown in \bsref{fig:actor_implicit_explicit}.

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/actor/figures/characteristics/actor_char_implicit_explicit} 
 \caption{The actor model on the implicit - explicit concurrency spectrum}
\label{fig:actor_implicit_explicit}
\end{figure}

\subsection{Fault Restrictive or Expressive Model}\label{sec_actor_fault_express}
The actor model forces some limitations on the programmer. The biggest limitation is that the model prohibits the use of shared mutable state and only allows isolated mutable state. Another limitation is that communication is limited to asynchronous message passing between actors. Furthermore, the atomic processing of messages ensures that only a single entity accesses mutable state at a time, however this disallows multiple read operations to happen simultaneously which is reasonable in regards to mutual exclusion. The actor model only permits the programmer to model the program by modelling individual actors and how they interact with one another. Based on these observations we say that the actor model is fault restrictive as shown in \bsref{fig:actor_fault_expressive}.

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/actor/figures/characteristics/actor_char_fault_expressive} 
 \caption{The actor model on the fault restrictive - expressive spectrum}
\label{fig:actor_fault_expressive}
\end{figure}

\subsection{Pessimistic or Optimistic Model}
The atomic processing of messages facilitates a pessimistic approach, as it allows only a single message to be processed at a time ensuring that only a single entity will access some mutable state at a time. Race condition issues are therefore avoided by design and a recovery mechanism for two entities simultaneously doing conflicting operations on mutable state is not needed. The actor model is in fact very pessimistic, as it enforces upon all state variables that only a single entity may access it at any given time. This can introduce unnecessary wait overhead if there are many immutable variables, that could have been accessed simultaneously safely. However, if the semantic property of state encapsulation is not adhered to in an actual actor implementation, it is possible to access the isolated state of another actor directly without sending a message, as illustrated earlier in \bsref{lst:actor_state_encapsulation_violation}. On \bsref{fig:actor_pes_opti} the placement visualizes the degree of how pessimistic the actor model is.

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/actor/figures/characteristics/actor_char_pessimistic_optemistic} 
 \caption{The actor model on the pessimistic - optimistic spectrum}
\label{fig:actor_pes_opti}
\end{figure}

\subsection{Readability \& Writability}
We base the evaluation of readability \& writability upon the same procedure as in \bsref{subsec:tl_charac_read_and_write}, due to the same concerns. First, the sub characteristics simplicity and orthogonality are evaluated for both readability \& writability, followed by an evaluation of the readability of the actor model. Afterwards the remaining sub characteristics for writability, level of abstraction and expressivity, are evaluated. Finally an evaluation of the writability of the actor model is presented.

\subsubsection{Low or High Simplicity}\label{subsec:actor_simplicity_read}
The actor model provides a fairly simple concurrency model, as race conditions are avoided by design. It also helps to avoid deadlocks, if the semantic properties are adhered to and the non-deterministic nature of asynchronous message passing is embraced, as discussed in \bsref{ssec:nondeter_msg_order}. However the actor model has a number of issues discussed in \bsref{sec:actor_discussion} that contribute negatively to its simplicity.

The majority of programmers are used to the mindset present in the imperative and \ac{OOP} paradigms where shared mutable state is promoted. The actor model requires a different mindset as it relies solely on isolated mutable state\cite[p. 9]{karmani2009actor}. Inadequate programmer experience can impact the simplicity of the actor model negatively initially, until programmers are accustomed to this new mindset. Additionally, sharing of behaviour among objects trough inheritance is common in \ac{OOP}, but it is not possible in the actor model, as discussed in \bsref{ssec:share_behaviour}. This impacts the simplicity negatively.

The non-deterministic message order is not suitable for every situation e.g. the stock example, as discussed in \bsref{ssec:nondeter_msg_order}. The conceptual actor model does not provide any constructs to prune away this non-determinism, so the programmer must build patterns for coordination manually. This reduces the simplicity of the actor model as the programmer must write a lot of boilerplate code each time a certain pattern is used. However, many actor implementations provides useful patterns for coordination, such as the request-reply pattern, which negates the negative impact on simplicity. Programmers however have to ensure that the use of such patterns does not lead to deadlocks.

It is not all actor implementations that adhere to all the semantic properties of the actor model, either to obtain a more efficient implementation or because of restrictions e.g. when implementing an actor library for an existing language. If the actor implementation does not adhere to the semantic properties of the actor model, it can affect the simplicity of the actor negatively, as it puts the responsibility on the programmer to enforce the properties themselves e.g. be sure not to break state encapsulation using an actor framework for an existing language.

As discussed in \bsref{ssec:actor_modelling}, there is an overhead in creating, sending and receiving messages. This means that there should not be too many small messages, as that will create a large overhead in relation to the number of messages. However, there should not be few large messages, as that will hurt the dynamics among actors. We do not find this as severe to the simplicity of the actor model as the other issues discussed, because no matter what concurrency model you use, you must be careful not to assign too much work to a single entity. 
%However, message size and load can be crucial to obtaining an efficient program.

The placement of the actor model on the simplicity spectrum is shown on \bsref{fig:actor_read_simplicity}. The actor model provides a fairly simple concurrency model that avoids race conditions by design. However, there are also a number of issues discussed above which has a negative impact on the simplicity. We have therefore placed the actor model between the middle and high simplicity end of the spectrum.

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/actor/figures/characteristics/actor_char_read_simplicity} 
 \caption{The actor model on the low - high simplicity spectrum}
\label{fig:actor_read_simplicity}
\end{figure}
%%%MORE:
%Måske noget om at man kan bruge actor modellen til at tænke over og modelere sine concurrency problmeber. (tror der står noget om det i scala actors i starten)
%the simplicity lies in that you do not have to worry about any explicit declaration as e.g. locking.
%Inadequete developer experinece, they used runnable because (kilde: scala actors mix):
	% used to traditional style of programming with shared state (Måske skriv et afsnit om det i acotr discussion)
	% legacy code they want to keep using it
	% did not want to trust a new techonology, when runnable would be enough for implementing required functionality
\subsubsection{Low or High Orthogonality}\label{sec:actor_orthogonality}
The actor model has a small amount of constructs for building concurrent programs. The main building block and abstraction is actors, that represent independent entities running concurrently. The other construct is messages, that enables communication between actors. Actors and messages can be combined in a large number of ways. An actor can however only send a message to a single actor at a time, but that can be simulated indirectly by e.g. having an \bscode{AllActor} that redirects the message to all other actors in the system. The actor model only allows a single actor to react to a messages. The message can however be simulated by modelling with additional actors. 

Actors can be modelled and combined in a way that produces cyclic dependencies, as discussed in \bsref{sec:actor_cyclic_dependency}. Such combinations are not desirable and if possible such combinations should be detected and disallowed. This hurts the orthogonality of the actor model as some of the combinations are not feasible. While the computation which created the cyclic dependency may livelock, the actors which are part of the cyclic dependency can continue to process other unrelated messages.

As the actor model consists of a small amount of constructs that can be combined in a large number of ways, it seems to have a high orthogonality. However as there are some combinations that are not directly allowed and others producing cyclic dependencies, it is not fully orthogonal. The degree of orthogonality for the actor model is shown \bsref{fig:actor_orthogonality}.

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/actor/figures/characteristics/actor_char_orthogonality} 
 \caption{The actor model on the low - high orthogonality spectrum}
\label{fig:actor_orthogonality}
\end{figure}

\subsubsection{Low or High Readability}
The simplicity and orthogonality discussed in the two previous sections directly influences the readability. Simplicity was placed between the middle and high end of the spectrum as it provides a fairly simple concurrency model but a different mindset is required for actor modelling and it introduces some new challenges which must be dealt with, such as non-deterministic message order. This negatively effects the readability of the actor model, at least until the programmer gets familiar with the different mindset and gets accustomed to these challenges. Orthogonality was placed in the high end of the spectrum, as there is a low amount of constructs which is able to be combined in a large number of ways, either directly or indirectly. This influences the readability of the actor model positively.

Additionally, all code in terms of state and behaviour methods associated with an actor is encapsulated and stored within the actor, which makes it easier to understand what a given actor encompasses. A programmer reading an actor program can start out by understanding how a single actor operates and then continue to examine how the actors that it communicates with operate, eventually leading to an understanding of the entire program. However it can also have a negative impact on the readability, as the flow of the program is distributed into the actors, so there is no single place to get an overview of the flow.

The readability of the actor model is shown on \bsref{fig:actor_readability} where it is placed between middle and high readability. It is not considered to have a very high readability due to the different mindset and new challenges the model introduces, which can be hard to understand at first.

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/actor/figures/characteristics/actor_char_readability} 
 \caption{The actor model on the low - high readability spectrum}
\label{fig:actor_readability}
\end{figure}

%more: 
% you clearly see what state varaibles an actor will ensure synchronization for in the way the model dictates isolated state
\subsubsection{Low or High Level of Abstraction}\label{sec:actor_level_of_abstraction}
The actor model lets the programmer focus on high-level concurrency abstractions and hides the complexities that can easily lead to errors, in order to simplify concurrent programming. Synchronization is accomplished implicitly as a result of actor mailboxes and atomic processing of messages. Threads are still used under the hood to run the actors, with different implementation strategies as discussed in \bsref{ssec:abstraction_over_threads}.

These high level abstractions enable the programmer to model and think about concurrent problems conceptually in terms of actors and their interaction, without having to write the program. However, the conceptual actor model does not provide any abstractions for coordination between actors to prune non-determinism. This affects the level of abstraction negatively, but most actor implementations typically have some useful coordination patterns, such as the request-reply pattern, which reduces the impact.

As illustrated on \bsref{fig:actor_level_of_abstraction} we place the actor model towards the high end of the level of abstraction spectrum. That there are no abstractions for coordination keeps the model from being at the extreme end of the spectrum.

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/actor/figures/characteristics/actor_char_level_of_abstraction} 
 \caption{The actor model on the low - high level of abstraction spectrum}
\label{fig:actor_level_of_abstraction}
\end{figure}

\subsubsection{Low or High Expressivity}\label{sec:actor_expressivity}
Expressivity relates closely to the level of abstraction. The actor model ensures mutual exclusion for all state variables implicitly and let the programmer express programs through the abstraction of actors, without having to worry about the complications of the underlying threads. Furthermore, an actor only needs the name of another actor to send it a message. The programmer does not have to worry about the complications in regards to communicating with another actor, such as the physical location of the actor and establishing a connection for sending the message to the actors mailbox. This location transparency enables simple distribution of actors on a cluster of machines. As an example, the Akka\footnote{\url{Akka.io}} actor implementation enables the programmer to program the system on a single computer and distribute actors to a cluster of machines by modifying a config file\cite[minute 25:45-27:20]{akkaLecture}.

However, as discussed in the level of abstraction characteristic, in the conceptual actor model the programmer must build patterns for coordination manually. This also affects the expressivity of the actor model negatively, but as most actor implementations have such coordination patterns it reduces the impact on expressivity.

Based on these observations we have placed the expressivity in the high end of the spectrum, as shown on \bsref{fig:actor_expressivity}. We have not placed it on the highest expressivity as programmers may have to build patterns for communication manually.

%TL complications: explicitly start, stop and synchronize threads and choose explicitly which state variables should be ensured mutual exclusion.
\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/actor/figures/characteristics/actor_char_expressivity} 
 \caption{The actor model on the low - high level of expressivity spectrum}
\label{fig:actor_expressivity}
\end{figure}

\subsubsection{Low or High Writability}
The actor model allows the programmer to express concurrency solely through modelling of actor entities and the communication between them. The details and complications of threads, physical location of actors and connection management for sending and receiving messages are abstracted away from the programmer. Furthermore, as the actor model consider only isolated state and atomic processing of messages, it provides simple synchronization by design which avoids race conditions. Abstracting away these complications makes it simpler to write concurrent programs and has a positive influence on the writability. Additionally, the model enables a valuable environment for testing as each actor can be tested in isolation. This also has a positive effect on the writability and makes it simple to use a test-first implementation technique.

However, the notion of no shared state and asynchronous message passing can hurt the writability of the actor model initially as it requires a different mindset. In some situations a non-deterministic message order is not feasible and patterns for coordination between actor are needed. Such patterns do not exist in the conceptual actor model, but are often included in actor implementations which reduces the negative impact on writability. Additionally, the programmer must also take into account some problems only releated to the actor model such as proper message size and overflow of an actor mailbox, as discussed in \bsref{sec:actor_discussion}.

Based on the above observations and the evaluation of simplicity, orthogonality, level of abstraction and expressivity we place the actor model between the middle and high end of the writability spectrum, as shown in \bsref{fig:actor_writability}.

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/actor/figures/characteristics/actor_char_writability} 
 \caption{The actor model on the low - high level of writability spectrum}
\label{fig:actor_writability}
\end{figure}

%if the programmer does not adhere to the async nature of message passing and force blocking behaviour deadlocks can often occur.
