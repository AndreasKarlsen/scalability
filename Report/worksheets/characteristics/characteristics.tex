\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Characteristics}{1}{April 24, 2013}{Someone}{../../}
This chapters presents the characteristic used to evaluate the chosen concurrency models.  Each characteristic will be presented along with a description of how it will be employed for evaluation. While many of the characteristic range from one extreme to another, all concurrency models do not have to reside at one of these extremes. Instead they can be position as some point in-between the two extremes.
\label{chap:char}
\section{Implicit or Explicit Concurrency}
Implicit concurrency allow libraries or the compiler to handle concurrency. Concurrency is hidden from the programmer who retains the illusion of a sequential program\cite[p. 59]{sutter2005software}. While enabling fast development of concurrency implementations and letting novice programmer take advantage of concurrency, implicit concurrency also has the drawback of limiting the concurrent execution gain, due to not all optimizations being feasible for strictly implicit concurrency. Further more, more advanced programmers can not apply their domain knowledge to further improve the concurrency execution gain.

Explicit parallelism is the opposite extreme of implicit parallelism. The programmer explicitly states where concurrency can occur as opposed to letting the runtime handle it\cite[p. 59]{sutter2005software}. As results programmers can now employ their domain knowledge to optimize the execution, allowing for utilization of the concurrent execution. The main drawback is however also closely tied to this. Programmers have to explicitly use concurrency abstractions to ensure correct behaviour in concurrent applications. Reasoning about concurrency is hard\cite[p. 56]{sutter2005software} and with explicit concurrency this burden is put unto the programmer.
\section{Fault Restricted or Expressive Mode}
\section{Pessimistic or Optimistic Concurrency Model}
A concurrency models can either pessimistic or optimistic. A optimistic model assumes that issues are uncommon and seeks to rectify the issue that occur, instead of guarding against them. In order to rectify the issues are recovery mechanism, such as rollback, is required. Based on the assumption of concurrency issue being uncommon, a optimistic concurrency model might seek to run as many concurrent tasks as possible at an given time attempting to reach optimal utilization of the available \ac{CPU} cores. 

A pessimistic concurrency model assumes that concurrency related issues are common and seeks to pro-actively guard against them. Because of this a pessimistic model might only run concurrent tasks when it can be guaranteed that they can will interfere with one another. Because a pessimistic model attempts to guard against concurrency issue occurring instead of letting them occur and then handling them, a recovery mechanism is not needed.

Weather a pessimistic or optimistic model is preferred depends on the many things including the problem being solved. Generally however, if many errors occur the pessimistic model will perform better than a optimistic as the optimistic will have to do atleast as many recoveries as there are errors. If however very few errors occur a pessimistic model will make a effort to guard against errors that seldom occur and a optimistic having to make few recoveries will perform better.
\section{Automatic or Manual Concurrency}
\section{Readability}\label{sec:readability}
Readability refers how easily a implementation is read and understood\cite[p. 8]{sebestaProLang}. It has been used as a characteristic for evaluating programming languages or implementations in a given programming language. We will employ it to evaluating readability of the general language constructs, for each of the selected concurrency models.

Readability is itself measured by measuring on a number of other characteristic. These are: simplicity, orthogonality, data types and syntax design. Of these we argue that only simply and orthogonality are applicable to evaluating concurrency models.

Simplicity refers to the overall simplicity of the model\cite[p. 8]{sebestaProLang}. That is issue such as, does multiple features exists for handling a given issue and how hard it is for programmers to understand a solution written using the model. 

Orthogonality measures the number of construct within a model versus how these construct can be combined\cite[p. 9]{sebestaProLang}. If a model uses only a few construct which can be combined in a large number of ways, we say that the model has high orthogonality. If on the other hand the model contains a high number of construct which can be combined in only a small number of ways we say the model has low orthogonality.

\section{Writability}
Writablility measures the ease with which a model can be used to solve a specific problem\cite[p. 13]{sebestaProLang}. As with readability, writability has been used to evaluate programming languages and is measured via a number of sub characteristics. In the case of writability these are: simplicity, orthogonality, data types, syntax design, support for abstraction and expressivity. Of these we argue that only simply, orthogonality, support for abstraction and expressivity are applicable to evaluating concurrency models.

Simplicity and orthogonality have largely the same meaning as was the case in \bsref{sec:readability}, the focus has however shifted from reading to writing code using the model. 


%write about support for abstraction and expressivity.
\section{Productivity}
\section{Scalability}
\section{Evaluation Method}

\worksheetend
