\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Future Work}{1}{April 24, 2013}{Andreas}{../../}
This chapter presents possible ideas for extending the work done in this project. The ideas are independent and presented in an arbitrary order.

\section{Extended Performance Test}
\label{sec:extended_performance_test}
As described in \bsref{sec:reflec_perf_test}, we discovered that the algorithm used for performance testing is parallel which proved somewhat problematic as the focus in this project is on concurrency. Therefore it could be valuable to further extend our performance tests with inherently concurrent problems such as the dining philosopher or santa claus problem\toby{as described in section reflection section}. Additionally it could be interesting to extend our performance tests with a set of problems with great diversity, to see how the individual models performs in the different domains. In \cite{imam2014savina} they propose a benchmark suite for actor oriented programs that ``\textit{range from popular microbenchmarks to classical concurrency problems to applications that demonstrate various styles of parallelism}'', it may be relevant to use some of these benchmarks as they present a set of problems with great diversity.

Another interesting factor for extending our performance tests could be to scale up to a higher number of cores. In our tests we have been using 8 logical cores, where 4 of them are physical, as described in \bsref{subsec:hardware}. In \cite{harris2003language}, they experience the scalability of different implementations varied after surpassing 35 cores. It could therefore be especially interesting to employ tests in a setting with above 35 cores.

\toby[i]{Uddyb mere?}

\toby[i]{Ved ikke om jeg kommer til at skrive meget af det samme som allerede står i rapporten? Ved performance test i reflection og i forhold til cores i test setup.}

\section{Actor Model}
As discussed in \bsref{ssec:adhere_actor_prop} actor implementations often choose not to adhere to one or more actor properties to gain better performance. A property that is often not adhered to is state encapsulation, in order to avoid the overhead introduced by deep coping message contents. Instead message passing is done by sending a reference to the message contents. However, this reintroductions the risk of race conditions, as multiple actors can access the same mutable state at the same time, which the conceptual actor model avoids by design. In \cite[p. 15]{haller2012actors} they state that it is an ongoing research effort to provide static checkers that can verify that programs passing mutable messages by reference do not contain race conditions. Also in \cite[p. 9]{karmani2009actor} they state that it is an active research topic, where they refer to it as safe efficient messaging. It could interesting to investigate this area as if such checkers could be developed it would relive the programmer with the burden of race conditions while an efficient performance. However this is only feasible in a local setting on a single machine, if the setting is a cluster of machines there is not a shared memory space. Though it is possible still possible to explore optimizations for communication and synchronization between co-located actors, as they also propose in \cite[p. 9]{karmani2009actor}.

In this study we investigated key concepts and characteristics of the actor model, and experimented with one actor model implementation. It could be interesting to develop a new actor model implementation in order to investigate how the different actor semantic properties affects performance and see how difficult a given property is implement and adhere to. In \cite{karmani2009actor} they address the question ``Can standard Actor semantic properties such as encapsulation, fair scheduling, location transparency and mobility be provided efficiently in an Actor framework on the JVM?'' by developing an actor framework which has comparable performance to other actor implementations which do not adhere to all the actor properties. It could be interesting to see if that is also the case on the .NET platform, by developing an actor implementation and comparing that to existing implementations on the platform. It could also be interesting to compare performance between actor implementations on the different platforms. Furthermore, when developing an actor implementation it could be relevant to look at useful coordination patterns, as there are not any such patterns in the conceptual actor model.\toby{Evt. refer til why do scala developors mix artiklen, der nævner de nogle advancerede coordination patterns}

%- Lav nogle af følgende koordinerings patterns i forbindelse med udvidelse af en actor framework,e ller vores eget (Tekst fra Why do scala developers mix... s. 319)
	%To address this problem, prior work has extended the Scala actor library with coordination patterns used in parallel programming, for example joins [12] and divide-and-conquer tasks [15]. More advanced coordination mechanisms for actor systems have also been proposed [4,31,9,27]. However,to the best of our knowledge, none has been integrated with a widely used actor library.
\section{\ac{STM}}
In this study we investigated key concepts and characteristics of the \ac{STM} model, and experimented with one \ac{STM} implementation. It could be interesting to develop a new \ac{STM} implementation in order to investigate how the different design choices for a \ac{STM} implementation affects performance and see how difficult a given approach is implement. It could especially be interesting to look at strong vs weak isolation which were discussed in \bsref{subsec:isolation_level}. Also a number of different \ac{STM} design approaches were discussed in \bsref{subsec:stm:variations_in_design}, including eager vs lazy updating, conflict detection, visible vs invisible reads, contention managers. Furthermore there may be additional \ac{STM} design approaches which we have not covered that could be interesting to include.
\worksheetend
