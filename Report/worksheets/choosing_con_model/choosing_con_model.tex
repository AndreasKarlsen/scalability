\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Choosing Concurrency Model}{1}{April 24, 2013}{Kasper}{../../}
This chapter presents a recommendation for choosing the right concurrency model for a given problem. A single concurrency model is not a perfect solution for all problems, there are strengths and weaknesses for each model.\andreas{Siger hvem? Det gør vi, da vi har undersøgt det}\toby{Det gør JVM sykroniserings manden også} The programmer must identify and choose the model or models with the most strengths and least weaknesses. In each of the following sections we will provide some guidelines for when a particular concurrency model is best applied.

\label{chap:choosing_con_model}


\section{\acl{TL}}\label{sec:choose_TL}
The \ac{TL} concurrency model has been employed for concurrent implementations for many years and is a widely supported technique for concurrent programming. While the \ac{TL} concurrency model does provide good performance it has a number of issues with its usability. Examining its characteristics reveals a low level of abstraction, low simplicity, low readability and low writability. The number of concurrency related issues the programmer has to reason about when employing the model is a great contributor to these low characteristic scores.

The programmer must be adept in avoiding these issues in order to produce correct concurrent implementations. Failing to do so can lead to serious issues such as race conditions and deadlocks. In the context of fine grained locking, avoiding these issues becomes even harder. However, if the programmer has sufficient expertise in the area, fine grained locking can be employed to bolster performance.

While locking has been employed for many years to produce concurrent implementations its issues limits its practicality. Alternatives, attempting to deal with these issues, have started to gain traction. Potentially spurred on by the need for concurrency due to the changes in hardware, as described in \bsref{chap:intro}. The \ac{TL} concurrency models however still offers good performance for correct implementations. Furthermore the programmer is free to tune the performance via the selected lock granularity, provided the programmer has sufficient expertise to do so. If only simply synchronization is needed locking may be sufficient. Especially if the programmer has existing expertise in the area of lock based synchronization.

\kasper[inline]{Composability}
\kasper[inline]{Only TL available $=>$ vælg tl}
\toby[i]{Remember to look at other characteristics from study in concurrency, one being: implicit and explicit}

%If performance is critical
%Has a number of well known issues which require great effort to avoid
%Fine grained locking is difficult but provides good performance
%Requires experiensed programmers in order to produce good implementatons when employing fine grained locking
%Widely support in many languages
%Limited composablity
\section{\acl{STM}}\label{sec:choose_STM}
\ac{STM} has been an active area of research for almost 20 years\cite{shavit1997software}. It has been included in existing languages trough both libraries\cite{rossbach2010transactional} and language changes\cite{harris2003language}, as well as included directly in newer languages such as Clojure. \ac{STM} eliminates the issue of deadlocks and scores around the middle or just above the middle in level of abstraction, simplicity, readability and writability. While \ac{STM} still require the programmer to explicitly apply synchronization to critical regions it manages to shift some of the workload away from the programmer. Memory transactions state that synchronization should be applied, but not how. The \ac{STM} system handles how synchronization is applied.

While memory transactions can be hard for novice programmers to understand \ac{STM} offers a number of usability advantages compared to \ac{STM}. The elimination of deadlocks makes \ac{STM} creating correct concurrent implementations simpler and composition trough nesting of transactions allows \ac{STM} based code segments to be combined without issues. 

With \ac{STM} converting a sequential implementation to a thread safe one can be as simple as applying the atomic block to the needed code segments. The programmer needs not reason about deadlock and the details of synchronization are handled by the programmer. In more complex cases the algorithm may need to be split up to support concurrent work. 

The availability of mature \ac{STM} implementations does however impact when the model can be applied. Some library based \ac{STM} implementations, such as \cite{ramadan2009committing} and \cite{herlihy2006flexible} require the use of \ac{STM} related types in order to track reads and writes. Language based implementations generally do no require such workarounds. The use of such types is undesirable as it may permeate parts of the source code and is far from the simplicity promised by the atomic block. Many programmers working in the industry will have requirements to which programming languages they employ. If these languages do not encompass a sufficiently simple \ac{STM} implementation, or maybe non at all, choosing another concurrency model may be desirable. If the problem at hand is simple, \ac{TL} is similar enough to \ac{STM} that the programmer may be able to employ that successfully instead.

As mentioned in \bsref{subsec:stm_irreversible_actions} STM has problems handling irreversible actions such as \ac{IO} and calls to native code. If the problem at hand encompasses a high degree of such operations then another concurrency may be preferred. If only a few of such operations are needed then another concurrency model can be employed for these code segments, while \ac{STM} can handle the remaining synchronization.


%parallisation of existing code (in the clean format)
%Good alternative to locks, especially if performance is not the top priority and programmers are familar with the shared memory concurrency and critical regions
%Currently suffers from not being well integrated in many of the languages popular in the industry 
%Concept of transactions can be hard to understand for novices
%Problems with IO and native method calls
\kasper[inline]{Programming concurrency on the JVM. Side 186}
\section{The Actor Model}\label{sec:choose_Actor}
The actor model offers a simple concurrency model as it lets the programmer focus on the high level abstractions and hides the low-level details of threads and synchronization.

%which lets the programmer focus on creating application logic

%Distrubuted systems - nice fit
%Design of large systems (back ends)
%Allows desgin of systems on a more high level
%Problems moving from sequeltial to actor implementation
%Application build around actors
%Best for new implementations or reimplementation of existing systems
%Functions well with pipeline processsing of input
%Context swiching is cheap compared to the other models (thread ring)
 	% light weight actors (maybe refer til actor framework comparison article)
%Problems expressing work where actors are dependant on one another
%readability and writability impact on the model
	%high simplicity and orthogonality
	%high level of abstraction and expressivity
%performance results impact on the model

%Hewitt's team wanted a model that would not only simplify building such concurrent systems, but would also let them reason about concurrent programs in general
\subsection{Closing Thoughts}
\kasper[inline]{Combine models instead of competing}
\kasper[inline]{TL $>$ stm hvis der er meget IO}

\worksheetend