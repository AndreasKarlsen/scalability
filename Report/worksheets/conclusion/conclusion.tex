\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Conclusion}{1}{April 24, 2013}{Andreas}{../../}
%
Motivated by the observation of Moore's law, software should be developed to exploit concurrency to gain run time performance. We have investigated the characteristics and run time performance of different concurrency models, and compared them to give an overview of their strength and weaknesses. To conclude our investigation, we will answer the questions in \bsref{sec:problemstatement}. This will be done by highlighting the noticeable observations made throughout the investigation.
\label{chap:conclusion}
\section{Question One}\label{sec:q_one}
The first question in the problem statement is ``Which issues exist with the traditional \ac{TL} concurrency model?''. 

To establish common ground the concepts of concurrency, parallelism, threads, processes and shared memory was outlined in \bsref{sec:processes_threads}. A key observation was that threads in the same process shared memory, and how synchronisation could be enforced with atomicity and condition synchronisation.

In section \bsref{chap:threads_locks} we presented the key concepts of using threads and shared memory. We outlined, that this approach suffered from race conditions. To remedy this, locks are used to enforce synchronisation at critical regions, and gives mutual exclusion between threads accessing the same memory. Locks come in forms as Mutex, Monitor, and Semaphore, each operating differently but with the same goal, to provide mutual exclusion. By using locks, the programmer risks introducing deadlocks, livelocks, priority inversion, starvation. These issues brings undesirable effects which we covered in \bsref{sec:tl_ci}, and is hard to avoid and discover as discussed in \bsref{subsec:tl_lock_hard}. Another caveat discussed in \bsref{sec:locks_me}, was the incapability of composing different lock based implementations, those prohibiting reuse of existing lock based implementations. 

We evaluated the characteristics of \ac{TL} in \bsref{sec_tl_char}, which summarize reasons why \ac{TL} is hard to use. The explicitness and low expressivity combined with low simplicity leaves the programmer with little help, and a lot of responsibility to, enforce synchronisation correctly. \ac{TL} suffers from low readability, which is caused by fragmented concurrency control leaving a large scope to focus on, and the difficulty of ensuring correctness in concurrent code. The model also suffers from low writability, primarily as a result of the difficulty of reasoning about critical regions.

Conclusively, the use of locks in the \ac{TL} model is hard to reason about, and introduces risk to the issues listed above. 

\section{Question Two}
To answer the second question, ``What are the characteristics of the selected models? Including their strengths and weaknesses'', each of the selected models was evaluated according to the characteristics defined in \bsref{chap:char}. A comparison of their characteristics was summarised and discussed in \bsref{chap:results}. Notable differences in characteristics will be outlined, and afterwards the strengths and weaknesses will be concluded.

\subsection{Characteristics}
A major difference is, whether the programmer needs to explicitly manage threads and synchronisation mechanisms. This is the case for \ac{TL} and \ac{STM}, but not for the actor model. The actor model is fault restrictive by design, and forces many restrictions on the programmer, e.g. isolated state and message passing for communication. This is in contrast to \ac{TL} that allows fine grained control of low level synchronization details. \ac{STM} is highly expressive, but gives some fault restrictions due to the automated transaction system. 

The models also differ in their approach to handling errors. \ac{STM} assumes everything goes well, and rolls back in the case where something goes wrong. This limits unnecessary waiting caused by synchronisation, but introduces the risk of having to retry the work of a transaction. \ac{TL} and the actor model are pessimistic. \ac{TL} enforces mutual exclusion to make sure nothing goes wrong in the first place and the actor model enforces state encapsulation through allowing communication only through message passing and processing of a single message at a time for a given actor.

The use of \ac{STM} combined with other language features such as \ac{IO} or native methods, is not elegant, and introduces complexity and low orthogonality. This is not the case when using \ac{TL}, but difficulty in reasoning about locks makes it even more complex. The actor model relies only on three actions, with which concurrency problems can be solved, and is thus the simplest. The composability of these actions gives the highest orthogonality. \ac{TL} has the lowest orthogonality, as combining locks easily produces erroneous implementations.

The implicit relationship between data and synchronisation, as well as fragmentation of the implementation causes the readability of \ac{TL} to be low. \ac{STM} suffers from the same, but removes the issue of deadlocks and thus increases the readability. The actor model encapsulates functionality and concurrency related code within an actor. It has the best readability, even though it is still hard to reason about the logic of an entire system, as the logic is divided among the actors.

The abstraction level of the actor model is high, as the programmer can think and implement concurrent problems without having to worry about low-level details. \ac{STM} uses a high abstraction for critical regions, but still uses threads which is considered low-level. \ac{TL} uses threads as well as locks as constructs for critical regions, which is considered low-level.  

\ac{TL} has low expressivity, as the programmer has to apply synchronization using low-level constructs. \acp{STM} expressivity transfers some of the strain from the programmer to the \ac{STM} system. Still issues related to integration with existing language concepts lower its potential expressivity. The actor model has the highest expressivity due to its high level constructs which allows a concise expression when solving concurrency problems.

\ac{TL} is effected by the issues just outlined, which causes its writability to be low. \ac{STM} allows composition and handles synchronisation from a higher level of abstraction than \ac{TL}, which gives a higher writability. The actor model abstracts details away, and provide a high level approach to dealing with concurrency, giving it the highest writability among the three models.

\subsection{Strengths and Weaknesses}
In \bsref{chap:choosing_con_model} we outlined the strengths and weaknesses in each model in order to recommend the right concurrency model for a given problem. To summarize, \ac{TL} is a mature technique which is widely supported. It provides a good performance when used correctly and allows for fine grained tuning. It has issues with usability, and requires experience to use. Incorrect use can cause problems such as race conditions and deadlocks. Solutions based on locks is hard to compose, which is a big weakness.

\ac{STM} gives a simple way to resolve race conditions. The programmer must still identify concurrency critical regions, but does not need to specify how to resolve it. It does however not integrate well with some language features, which makes it undesirable for certain solutions. The mindset of using \ac{STM} can require some time to get used to, and requires practice to understand in depth. \ac{STM} also introduces some uncertainty in run time performance, as transactions optimistically runs calculations, and a conflict results in performance overhead. As conflicts mostly happens in write intensive scenarios, \acp{STM} strength lies in reading intensive scenarios.

The actor model offers a simple concurrency model, which abstracts away from threads and details of synchronisation. It requires a different approach to solving problems, as the communication between actors is solely based on message passing. This is the key to its simplicity but it also requires a different mindset when reasoning about concurrency than programmers are used to. In order to use the actor model, all of the logic must be encapsulated in to actors and interaction among actors through messages. It is therefore hard to retrofit a program to run concurrently by using actors. Another strength of the actor model, is the possibility to scale across multiple instances in a distributed environment, if the semantic properties are adhered to.


\section{Question Three}
The third question is ``How do the selected models handle concurrency issues known from the traditional \ac{TL} approach?''. 

As discussed in \bsref{sec:q_one} the issues known in the traditional \ac{TL} approach are race condition, deadlock, livelock, priority inversion, and starvation. 

In \bsref{chap:stm} we outlined how \ac{STM} works, and handles concurrency issues. To summarize, \ac{STM} negates the risk of race conditions by allowing the programmer to define a concurrency critical region. All code executed in this region is safe from concurrency issues, however if the programmer leaves out a concurrency critical region, when there should have been one, race conditions can still occur. Deadlocks and livelocks does not exist in \ac{STM}, as it does not wait for another thread, but simply retries and thus never wait. The same holds for priority inversion, since no thread waits for another. There is however a risk of starvation. Since a transaction gets aborted if a conflict occurs, there is a risk of the same transaction being cancelled repeatedly, and thus never finishes. Contention managers and other strategies exists to remedy this issue.

We outlined the key concepts of the actor model and its concurrency issues in \bsref{chap:actor}. The actor model avoids race conditions by design, since there is no notion of shared mutable state, instead only isolated mutable state is allowed. The encapsulation actor property, discussed in \bsref{ssec:adhere_actor_prop}, is a key factor in ensuring race conditions are avoided, so the programmer adhere to this property if the actor implementation does not enforce it. The communication between actors is through message passing, and the internal state of an actor can only be altered by itself, handling messages atomically. The risk of deadlocks\andreas{Hvad med livelocks? Hjælper in-determinism imod dem :)?} still exists in the actor model, although it is reduced by avoiding blocking waits. A scenario where two or more actors are waiting for messages from one another produces a deadlock. Contrary to a thread busy-waiting, an actor can still send and receive messages from and to other actors, which means other actors unrelated to the deadlock will keep functioning. 
Something about livelocks%In terms of livelocks they are very unlikely to occur and the programmer must deliberately model actors to produce one.
Priority inversion is not present in the actor model as there is no shared state and it is not possible to prioritize actors or their messages.\toby{Hvad siger i til det?}Conceptually starvation does not exist, since fairness is assured as a semantic property of the actor model. That is, a message sent is eventually received. However, it varies whether frameworks adhere this property, which is typically done to simplify the actor implementation or to obtain better performance. The fairness also applies to priority inversion together with that messages are proc

\section{Question Four}
``How is the implementation efficiency of the selected models?''


Using the knowledge obtained from answering these questions, we will present an overview of the selected concurrency models. Specifically an overview of their characteristics and implementation efficiency, along with a set of suggestions for when to apply each model.




The learning goals are defined as:
\begin{enumerate}
\item Learn what concurrency models exist and in what setting they are best applied.
\item Produce a sample implementation using each of the selected models in order to gain hands-on experience.
\item Get hands-on experience with the Scala\footnote{\url{http://www.scala-lang.org/}} programming language as it is gaining traction in the area of highly concurrent web services.
\end{enumerate}
\worksheetend