\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Software Transactional Memory}{1}{November 7, 2013}{Andreas}{../../}
This chapter investigates \ac{STM} as a concurrency model. In \bsref{sec:stm_keyconcepts}, the key concepts of \ac{STM} are described. \bsref{sec:stm_issues} documents the concurrency issues introduced by \ac{STM}. \bsref{sec:stm_discussion} discusses the properties of \ac{STM}. Finally, in \bsref{sec:stm_eval} an evaluation of \ac{STM} as a concurrency model is conducted.
\label{chap:stm}
\kasper[inline]{Look in "kandidat opgave/literature/STM/State of the art" and TM book for talking about STM implementations. Eg time based STM}

\section{Key Concepts}
\label{sec:stm_keyconcepts}
This section presents the key concepts of \ac{STM}. It clarifies the concepts of \ac{STM}, so the discussion and comparison in the subsequent sections can be at a higher level of abstraction.

\subsection{\acl{TM}}
\label{sec:tmevo}
In \cite{herlihy1993transactional} the authors proposes a way to implement \ac{TM} at hardware level. Due to the inflexible properties of hardware, i.e. fixed instruction set and limited register size, \ac{TM} implemented on hardware is limited to existing instructions and can only handle transactions of limited size\cite{dragojevic2011stm}. This causes high implementation and verification costs\cite{cascaval2008software}. \ac{HTM} also exposes low level hardware details and limitations\cite{herlihy2011tm}, which preferably should be abstracted away from the programmer, to ensure semantic correctness of the transactions regardless of the hardware limitations. 

Due to these caveats, a software based solution is presented by \cite{shavit1997software}. This solution, entirely implemented as software, is known as \acl{STM}. Being implemented as a software solution, \ac{STM} does not suffer the same issues as \ac{HTM}, but still provides the transactional semantics. However, providing these semantics in software only, comes with a performance penalty\cite{cascaval2008software}\cite{dragojevic2011stm}.

Recently \ac{HTM} has been adopted by Intel and IBM and integrated into the Haswell and POWER8 processors respectively\cite{Anthes:2014:RSP:2684442.2667109}. Researchers hope to develop a hybrid model, which leverages the low level \ac{TM} instructions on the \ac{CPU} for good performance, while providing a transactional programming model to the developer at software level, to make the high level programming simpler, efficient, and well structured\cite{Anthes:2014:RSP:2684442.2667109}.

Despite the recent development in the area of \ac{HTM}, the availability of \ac{HTM} or hybrids in high level programming languages is to our best knowledge non-existent. One could speculate, that the programming model to the programmer will remain unchanged, but the underlying runtime will benefit from the new \ac{HTM} semantics available, and therefore the characteristics of the \ac{STM} programming model could be the same. Due to these observations, \ac{STM} is the focal point of our investigation in \ac{TM} as a concurrency mechanism. 

\subsection{Transactional Properties}
\label{sec:stm_tm_properties}
\ac{TM} is based on the concept of a transaction. A transaction is a finite sequence of machine instructions, executed by a single process, satisfying following properties\cite[p. 2]{herlihy2011tm}.

\paragraph{Atomicity} By considering the instructions in a transaction as indivisible, atomicity ensures a shared effect of all the instructions in the transactions, either success or failure. That is, either all the instructions succeed to change the state of the system or none of them take effect e.g. if a single instruction in a transaction fails, all will fail.
\paragraph{Isolation} A transaction is only perceived before or after its execution, never in the middle. That is, the work of a transaction can be perceived to occur instantaneously. This can be either from the view of the entire system, or other transactions. We will elaborate on this in \bsref{subsec:isolation_level}. 

\ac{TM} can perform a group of memory-operations atomically\cite[48]{harris2005composable}\toby{Den står lidt som et fact der ikke bliver bygget mere på, måske byg denne sætning sammen med næste eller uddyb}. By utilizing the transactional approach, \ac{TM} serves as a concurrency control mechanism. By adhering to the aforementioned properties, \ac{TM} enables concurrent execution, while being semantically equivalent to serial execution of the same program.

\subsection{\acl{STM}}\label{sec:stm_stm}
\ac{STM} provides programmers with a transactional model, in software, through a library or compiler interface\cite{herlihy2011tm}. It seeks to solve the issues introduced by running multiple processes concurrently in a shared memory space, e.g. race conditions as discussed in \bsref{subsec:race_coditions}. To handle these challenges, \ac{STM} offers the programmer ways to define transaction scopes in critical regions. The transactions are executed concurrently, and if successful, changes are committed. If the transactions are not successful, it will be retried. Just by defining the critical regions, the \ac{STM} takes care of ensuring the atomicity and isolation leaving no work left for the programmer. 

As our preliminary investigation showed in \bsref{sec:prelim_stm}, a number of programming languages and libraries have emerged to support TM. We have chosen Clojure, since \ac{STM} is natively implemented in the language, and it runs on the \ac{JVM}. The example in \bsref{lst:stmexample} demonstrates a transaction in Clojure on line 5, specified with the \bscode{dosync} function. Two accounts, \bscode{account1} and \bscode{account2} respectively, are defined as a reference to an amount. The function \bscode{transfer} takes an amount, and two accounts as parameters. In a transaction, it then transfers the amount given, from one account, to the other.

\begin{lstlisting}[label=lst:stmexample,
  caption={STM in Clojure},
  language=Lisp,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings}]  % Start your code-block

	(def account1 (ref 100))
	(def account2 (ref 0))

	(defn transfer [amount from to]
    	(dosync
    		(alter from - amount)
    		(alter to + amount)))
       
\end{lstlisting}

To clarify the effect of using \ac{STM}, \bsref{fig:transaction} visualizes the flow of an example of two transactions running concurrently. Both transactions \bscode{t1} and \bscode{t2} are in the same process, and therefore share memory. The variable \bscode{x} is stored in this memory. Both transactions have a reference to variable x. We use the concept of revisions of a variable, to describe how the value of it evolves. First off, both \bscode{t1} and \bscode{t2} are reading the initial value of x. They want to perform a statement to update the value of x, leading to a race condition. \bscode{t1} finishes its statement first, and wants to commit its transaction. This is allowed, since the revision of x is unchanged since the read. Afterwards, \bscode{t2} wants to commit its transaction. This is disallowed, since the revision of x now has increased. \bscode{t2} then retries its transaction, by re-reading the value of x, performing the statement again, and committing the transaction. This is now allowed, since x is the same revision as when it was read by \bscode{t2}. It is clear from the example given, that \ac{STM} remedied the risk of race conditions.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{\rootpath/worksheets/stm/figures/transaction}
\caption{Two transactions share memory and both have a reference to variable x. They have a racecondition, both doing calculations based on x, and writing back to x. \ac{STM} ensures that there is no lost update when t2 attempts to write, and enforces a recalculation with the new x value.}\label{fig:transaction}
\end{figure}

\subsection{Conflicts}
\label{sec:stm_conflicts}
In the context of \ac{STM} a conflict is two transactions performing conflicting operations on the same data, resulting in only one of them being able to continue\cite[p. 20]{harris2010transactional}. A conflict arises if two transactions attempt to write to the same data, or if one transaction reads the data while the other writes to it.

A \ac{STM} system taking some action to avoid a conflict is called conflict resolution\cite[p. 20]{harris2010transactional}. When two transactions conflict two options exist for resolving the conflict:\begin{inparaenum}[(1)]
\item pausing a transaction, attempting to let the other transaction finish
\item letting a transaction proceed, forcing the other transaction to abort.
\end{inparaenum} 
\subsection{Common Language Constructs}
\label{sec:stm_common_constructs}
Languages supporting \ac{STM} must encompass some language construct for specifying that a section of code should be executed as a transaction and managed by the \ac{STM} system. This basic language construct is often referred to as the \bscode{atomic} block\cite[p. 49]{harris2005composable}\cite[p. 3]{harris2003language}. The \bscode{atomic} block allows programmers to specify a transaction scope wherein code should be executed atomically and isolated as described in \bsref{sec:stm_tm_properties}. The atomic block is exemplified in \bsref{lst:stm_atomic_block}. Exactly how a transaction scope is defined, varies between \ac{STM} implementations. As an example, Clojure employs the \bscode{dosync} function as shown on line 5 in \bsref{lst:stmexample} while a library based system such as JDASTM\cite{ramadan2009committing} uses calls to \bscode{startTransaction} and \bscode{commitTransaction} methods.

\begin{lstlisting}[label=lst:stm_atomic_block,
  caption={The atomic block},
  language=Lisp,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic}]  % Start your code-block

	atomic{
		v1 = x;
		v2 = y;
		z  = v1 / v2;	
	}
       
\end{lstlisting}

\subsubsection{Conditional Synchronization}
\label{subsec:stm_conditional_synchronization}
A common task in concurrent programming is executing code whenever some event occurs. As an example consider a concurrent queue shared between multiple threads in a producer consumer setup. It will be useful to only have a consumer dequeue an item whenever one is available. Accomplishing this without the need for busy waiting would also be preferable.

In \cite{harris2005composable} Harris et al. introduce the \bscode{retry} statement for assisting in conditional synchronization within the context of \ac{STM}. The \bscode{retry} statement is explicitly placed by programmers within an \bscode{atomic} block. If a transaction encounters a retry statement during its execution it indicates that the transaction is not yet ready to run and the transaction should be aborted and retried at some later point\cite[p. 73]{harris2010transactional}. The transaction is not retried immediately but instead blocks, waiting to be awoken when the transaction is to be retried. The transaction is typically retired when one of the variables involved in the transaction is updated by another transaction\cite[p. 51]{harris2005composable}. By blocking the thread instead of repeatedly checking the condition, busy waiting is avoided.

A transaction using the \bscode{retry} statement is shown in \bsref{lst:stm_retry}. If the queue is empty the transaction executes the retry statement of line 3, blocking the transaction until it is retired at a later time.
\begin{lstlisting}[label=lst:stm_retry,
  caption={The retry statement},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry}]  % Start your code-block

	atomic{
		if(queue.isEmpty())
			retry;
		item = queue.dequeue();
		//process item
	}
       
\end{lstlisting}

In addition to the \bscode{retry} statement Harris et al. propose the \bscode{orElse} block. The \bscode{orElse} block handles the case of waiting on one of many conditions to be true by combining a number of transaction alternatives. The alternatives are evaluated in left-to-right order and only one of the alternatives is committed\cite[p. 52]{harris2005composable}. The \bscode{orElse} block works in conjunction with the \bscode{retry} statement to determine which alternative to execute. An example of a transaction employing the \bscode{orElse} block is shown in \bsref{lst:stm_orelse}. If an alternative executes without encountering a retry statement it gets to commit and the other alternatives are never executed\cite[p. 74]{harris2010transactional}. If an alternative however encounters a \bscode{retry} statement its memory operations are undone and the next alternative in the chain is executed\cite[p. 74]{harris2010transactional}. If the last alternative encounters a \bscode{retry} statement the transaction as a whole is blocked awaiting a retry at a later time\cite[p. 74]{harris2010transactional}.

\begin{lstlisting}[label=lst:stm_orelse,
  caption={The orElse block},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse}]  % Start your code-block

	atomic{
		{
			if(queue.isEmpty())
				retry;
			item = queue.dequeue();
		}orElse{
			if(queue2.isEmpty())
				retry;
			item = queue2.dequeue();
		}orElse{
			if(queue3.isEmpty())
				retry;
			item = queue3.dequeue();
		}
	}
       
\end{lstlisting}

\subsection{Zombie Transactions}
\label{subsec:zombie}
A zombie transaction is a transaction which will eventually abort, but have not yet discovered so. This happens, when a transaction has observed an inconsistent read-set\cite[p. 196]{dice2006transactional}. E.g. if a transaction reads the value of a variable, which is then updated by another transaction afterwards. This is exactly the case of \bscode{t2} in the example in \bsref{fig:transaction}.

\subsection{Level of Isolation}
\label{subsec:isolation_level}
Within the context of \ac{STM} there exist two different isolation levels: weak isolation and strong isolation. Isolation describes how parts of a system perceive transactions. The terms isolation and atomicity are used interchangeably throughout the literature\cite[p. 30]{harris2010transactional}.

With the guarantee of isolation, a transaction is perceived as one atomic step. That is, the intermediate states present during the execution of the transaction are not perceived by other parts of the systems, only the committed values become visible to other parts of the system. This always holds in the case of transactions perceiving other transactions. However, if a thread executes transactional code over some data, and another thread executes non-transactional code over the same data, the concepts of weak and strong isolation handle this differently.

In the case of strong isolation it is guaranteed that transactions are atomic with respect to non-transactional access\cite[p. 2083]{herlihy2011tm}. If any data is access both within a transaction as well as out side of a transaction the \ac{STM} implementation will ensure that the variable is accessed atomically in both cases. Guaranteeing isolation atomicity between transactional and non-transactional access comes with a  performance cost\cite{herlihy2011tm}. 

Weak isolation only guarantees that transactions are atomic with respect to other transactions. That is, it is up to the programmer to ensure that non-transactional access does not interfere with transactional access.

\section{Concurrency Issues}
In this section we present the concurrency issues related to the use of \ac{STM}. We will also relate to the concurrency issues discussed in \bsref{subsec:race_coditions} and \bsref{sec:tl_ci}.
\label{sec:stm_issues}

% Composition is possible in STM. Reference to Kaspers example about composition.
% STM compared to locks
\subsection{Race Conditions}
In a setting with shared memory and multiple threads, the risk of race conditions are present. In order to negate this risk, \ac{STM} enables the programmer to define blocks of code, that must be executed with atomic semantics. The atomicity of \ac{STM} ensures that the execution appears to take effect instantaneously, hence no race conditions can occur between transactions. This holds for both \ac{STM} with weak and strong isolation.

As the programmer explicitly has to mark code in atomic blocks to ensure safety, the risk of the programmer not marking the code, will make the code prone to race conditions. This holds true only for weak isolation level, as \ac{STM} with strong isolation will account for changes made outside transactions. The responsibility of marking critical regions varies in different implementations of \ac{STM}. Some implementations have special reference types, that can only be modified inside a transaction. This enforces the programmer to use transactions every time he wants to manipulate the value of the reference. An example of using approach is Clojure, which is a functional language that promotes immutability, and only allows mutable references to be manipulated in transactions. In \bsref{lst:stmexample} the variables \bscode{account1} and \bscode{account2} are references, and they can only be manipulated in the transaction block, which is named \bscode{dosync}.

\subsection{Starvation}
There is a risk for starvation when using \ac{STM}. The work of transactions are executed optimistically, and are aborted if a conflict occurs. If the same transaction keeps getting aborted and must retry its work, it might never finish. To remedy this, different strategies exists. As described in \bsref{subsub:con_managers} a contention manager can use different strategies to ensure that transaction do not starve.

\subsection{Side-effects in Transactions}
\label{subsec:stm:side_effects}
There is no straight forward approach to handle side-effects, such as exceptions, inside transactions. A viable approach proposed by Tim Harris\cite{harris2003language} is to only propagate the exception when the transaction is able to commit, since this is the only case a transaction causes changes impacting the rest of the system. However, even though a transaction is successful, if an exception happens all of the content of the transaction might not be executed, and can leave the program in an invalid state. To exemplify, \bsref{lst:stm_exception} illustrates this issue. The method \bscode{move} moves an object from one collection to another. This happens in an atomic block, to ensure thread safety. However, if an exception happens while trying to add the object to the destination at line 7, the programmer must manually secure that it is re-added to the source. If not, the object will be in neither collection if the transaction commits. 
\kasper{Har ændret referencen til det paper du præsenterede. Måske figuren og skal til passes den da passer til det som præsenteres i det andet paper.}
\begin{lstlisting}[label=lst:stm_exception,
  caption={[Exceptions in Transactions]Exceptions in Transactions \cite[p. 3]{harris2003language}},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse}]  % Start your code-block

	boolean move(Collection source, Collection destination, Object object){
		atomic{
			if(!source.remove(object)){
				return false;
			} else {
				try { 
					destination.add(object);
				} catch(RuntimeException exception) {
					source.add(object);
					throw exception;
				}
				return true;
			}
		}
	}      
\end{lstlisting}

A way to negate this issue, is to retain all changes made in the transaction up until the point of the exception. By letting the \ac{STM} system discard the side-effects happening before the exception, the programmer does not have to undo the actions before the exception. While this is a desirable feature, its implementation is difficult to realize\cite[p. 3]{harris2005exceptions}.

Another approach is handle side-effects, is to avoid them partly or entirely. Functional languages with \ac{STM} such as Clojure or Haskell promotes immutability and is pure in regards to side-effects. This property makes it easier to handle transactions, since there is only side-effects in relation to the transaction itself. 

\subsection{Irreversible Actions}
\label{subsec:stm_irreversible_actions}
Transactions in \ac{STM} requires that aborted transactions does not cause effects. That is, if the value of a variable is manipulated in a transaction, and the transaction is aborted, the rest of the system should never see the variable changed. This raises a problem, since some actions are not reversible, e.g. \ac{IO} performed on a disk, or network access. These are irreversible actions, and even by not committing the result of a transaction, the transaction have still affected the system. 

To handle this, special precautions must be taken. There is different approaches to handle this issue. In \cite[p. 4]{harris2003language} all native methods raises a runtime exception. A native method is defined as a method using system calls. In Java context, that is when a method must leave the virtual environment of the \ac{JVM}. In \cite{harris2005exceptions} a proposal to make libraries using native methods implement a specific interface to enable cooperation with \ac{STM}. The idea is, that they will buffer their effect, until they get a callback when their transaction is committed. 

Another approach is, to enable the developer to mark a function, so the \ac{STM} is aware of its side effect. In Clojure it is possible to do this with the \bscode{#IO} macro. If a function is marked, and used in a transaction, a compiletime exception will be raised. In Haskell the \bscode{IO} monad is used to encapsulate the effect, and can be evaluated later, once the transaction is successful.

\subsection{Contention}
%What is contention
The amount of read and writes in a memory area can be described as a contention level\cite[p. 2084]{herlihy2011tm}. A high level of contention will cause poor performance in concurrent programs. Especially in \ac{STM}, since multiple transactions trying to manipulate the same memory, a cause a conflict. When the contention level is high, the amount of conflicts will raise, and the work made by transaction being aborted is going to waste. In \ac{TL} a high contention level will cause the threads to wait, at worst being limited to linear execution, but no work will go to waste. 

Due to the performance impact of contention level, it is a significant factor in the design of \ac{STM} implementations. It is an important factor in \cite{harris2003language} and in \cite{herlihy2008transactional} specific research have been done to resolve this issue.

\section{Discussion}
\label{sec:stm_discussion}
This sections describes and discusses issues related to \ac{STM}. \bsref{subsec:stm:variations_in_design} describes design alternatives related to \ac{STM} systems. \bsref{sec:stm_composability} describes how \ac{STM} can support composability by allowing transactions to be nested within other transactions. Finally \bsref{sec:stm_ease_of_use} describes tow ease of uses studies conducted into the area of \ac{STM}.

\subsection{Variations in \ac{STM} Design}\label{subsec:stm:variations_in_design}
Different approaches for designing \ac{STM} systems exist. Many of the approaches represent a trade off between different aspects of the system. This section describes a number of design issues as well as the trade off's they represent.

\subsubsection{Eager vs Lazy Updating}
Updating memory in a \ac{STM} implementation can be done either using: eager or lazy updating.

Eager updating updates the memory associated with a variable directly and is also referred to as in-place-updating, as updates are written into the existing memory location\cite[p. 35]{afek2011lowering}. \ac{STM} implementations using eager updating, must maintain an undo log, which stores information about any writes made within transactions. The undo log is used to undo the effects of a transaction when a transaction conflicts\cite[p. 2084]{herlihy2011tm}.

Lazy updating takes the opposite approach and writes updates to local versions of the effected data\cite[p. 2084]{herlihy2011tm}. If the transaction commits, the local changes are written to the actual memory locations, while an abort causes the local changes to be discarded.\toby[inline]{Evt. noget om at lazy updating bruger mere plads fordi vi har kopier fremfor en changelog, men at hvis der så er conflicter er det nemmere at discare kopier fremfor at skulle til at udføre en changelog.}

Eager updating allows efficient commit of transactions but makes it harder to ensure that zombie transactions see consistent state\cite[p. 2084]{herlihy2011tm}.

\subsubsection{Conflict Detection}
\label{sec:stm_conflict_detection}
The act of determining whether a conflict has occurred is called conflict detection\cite[p. 20]{harris2010transactional}. Different ways of handling conflict detection exist. Eager conflict detection detects conflicts whenever a transaction attempts to access shared data, while lazy conflict detection detects conflicts just before a transaction is about to commit by validating the transactions data access\cite[p. 21]{harris2010transactional}. A lazy conflict detection scheme discards more computations that a eager scheme while a eager conflict detection scheme may cause transaction that could have committed lazily to abort\cite[p. 21]{harris2010transactional}.

Besides lazy and eager conflict detection another distinction lies in what transactions are included when performing conflict detection. A \ac{STM} system employing tentative conflict detecting will include currently active transactions when detecting conflicts, while a system using committed conflict detection only detects conflicts with already committed transactions. Eager conflict detection is often coupled with tentative conflict detection while lazy conflict detection is often coupled with committed conflict detection\cite[p. 22]{harris2010transactional}.

Conflict detection is highly related to the concepts of pessimistic or optimistic concurrency control. In pessimistic concurrency control conflicts are detected and resolved when they happen\cite[p. 20]{harris2010transactional} while optimistic concurrency control detects and resolves conflicts some time after they occur\cite[p. 20]{harris2010transactional}.

\subsubsection{Visible vs Invisible Reads}
\andreas[inline]{Do we make use of this? Very implementation specific}
When reading shared data \ac{STM} implementations can either employ visible, invisible or semivisible reads.

Using visible reads a \ac{STM} transaction communicates its operations to other transactions, by registering in shared memory whenever it reads a shared variable\cite[p. 2]{lev2009anatomy}\cite[p. 2085]{herlihy2011tm}. Other transactions, which are about to write to a shared variable, can then consult the written data to identify if they are about to produce a conflict. As transactions write exactly which transaction reads a variable, the writing transaction can choose to abort the reading transactions\cite[p. 2]{lev2009anatomy}.

Using invisible reads a \ac{STM} transaction does not communicate its operations to other transactions\cite[p. 114]{imbs2012virtual}. Each transaction instead maintains per read metadata which is used to validate the transaction whenever additional reads are performed\cite[p. 2085]{herlihy2011tm}.

Visible reads have the problem of being expensive and not scaling, while invisible reads are expensive due to their need for repeated validation. As such, more recent \ac{STM} implementations instead employ the semivisible read scheme\cite[p. 2085]{herlihy2011tm}.

Semivisible reads are similar to visible reads in that transaction communicate their reads to other transactions. Instead of communicating exactly what transaction read a shared variable, a transaction simply indicates that a given variable has been read by some transaction, allowing other transaction to see that a conflict exists. A counter is maintained for each transaction indicating if any conflicts occured during its execution. Expensive validation can be avoided in the vast majority of cases by checking whether any conflicts occurred during the execution of a transaction\cite[p. 2]{lev2009anatomy}.

\subsubsection{Contention Managers}
\label{subsub:con_managers}
Some \ac{STM} implementations delegate conflict resolution to a component called a contention manager\cite[p. 2085]{herlihy2011tm}. The contention manager encapsulates the \ac{STM} implementations conflict resolution policy\cite[p. 2085]{herlihy2011tm} and ensures that the \ac{STM} systems as a whole makes progress\cite[p. 1]{guerraoui2005toward}. The decision of how a to resolve a conflict can be delegated to the contention manager. Not all \ac{STM} implementations use a contention manager, but instead abort transactions immediately\cite[38]{riegel2013software}.

The decision can be delegated to a contention manager. The contention manager encapsulates the \ac{STM} implementations conflict resolution policy\cite[p. 2085]{herlihy2011tm}.

In \cite{scherer2004contention} the authors examine a number of contention manager implementation policies. By benchmarking the a implementation of the policies the authors reveal that all policies which performed well in atleast a single test, performed abysmal in atleast one other test. So no single best contention management policy was identified.

\subsection{Composability}
\label{sec:stm_composability}
As discussed in \bsref{subsec:tl_composability} concurrent implementations based on the \ac{TL} concurrency model do not compose, mainly due to the threat of deadlocks. \ac{STM} avoid the issue of deadlocks and addresses composition by allowing transactions to be nested within other transactions. The basic concept is exemplified in \bsref{lst:stm_nested_transactions}. The outer transaction defined on line 1 encloses another transaction defined on line 3.

\begin{lstlisting}[label=lst:stm_nested_transactions,
  caption={Nested transactions},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var}]  % Start your code-block

	atomic{
		x = 5;
		atomic{
			x = 10;		
		}
	}
       
\end{lstlisting}

\bsref{lst:stm_nested_transactions_real} presents a more real world example based on transferring funds from one account to another. Here a outer transaction, defined on line 1, encloses two method calls to \bscode{withdraw} and \bscode{deposit} which are defined using transaction. Their transaction are effectively nested within the outer transaction.
\begin{lstlisting}[label=lst:stm_nested_transactions_real,
  caption={Real world nested transactions},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse, var}]  % Start your code-block

	atomic{
		var amount = 500;
		account.withdraw(amount);
		account.deposit(amount)
	}
       
\end{lstlisting}

Three main forms of transaction nesting exist: flat nesting, closed nesting and open nesting\cite[p. 1]{kumar2011hparstm}\cite[p. 42]{harris2010transactional}. Flat nesting aborts the outer transaction if a inner transaction aborts and commits from enclosed transactions only take effect when the outer transaction commits. Under closed nesting, aborting a enclosed transaction does not terminate the outer transaction and commits made by enclosed transaction become visible to the outer transaction but not transaction executed by other threads. Under open nesting commits from enclosed transactions become visible to every other transaction and if the outer transaction aborts results of committed enclosed transactions are not rolled back. Flat nesting is simpler than closed and open nesting while open and closed nesting allows for a greater degree of concurrency, especially in cases where aborts are common\cite[p. 43]{harris2010transactional}.

%\kasper[inline]{Skal lige overveje om den skal med}
%\begin{lstlisting}[label=lst:observer_transactions,
%  caption={Observer pattern with transactions},
%  language=Java,  
%  showspaces=false,
%  showtabs=false,
%  breaklines=true,
%  showstringspaces=false,
%  breakatwhitespace=true,
%  commentstyle=\color{greencomments},
%  keywordstyle=\color{bluekeywords},
%  stringstyle=\color{redstrings},
%  morekeywords={atomic, retry, orElse, var}]  % Start your code-block
%
%	public class ValueStore implements Observable{
%
%    private int value = 0;
%    private List<Observer> observers = new ArrayList<>();
%
%    public void setValue(int newValue){
%		List<Observer> shallowCopy;        
%        atomic{
%            value = newValue;
%            shallowCopy = new ArrayList<>(observers); 
%        }
%        
%        for (Observer o : shallowCopy) {
%                o.notify(this,newValue);
%        }
%    }
%
%    @Override
%    public void register(Observer observer){
%        atomic{
%            observers.add(observer);
%        }
%    }
%
%    @Override
%    public void unregister(Observer observer){
%        atomic{
%            observers.remove(observer);
%        }
%    }
%	}
%	
%	public class ValueObserver implements Observer {
%
%    @Override
%    public void notify(Observable sender, int value){
%        sender.unregister(this);
%    }
%	}
%
%	public class Main {
%
%    public static void main(String[] args){
%        ValueStore observable = new ValueStore();
%        observable.register(new ValueObserver());
%        observable.setValue(5);
%        System.out.println("Done");
%    }
%	}
%\end{lstlisting}
\subsection{Ease of Use}
\label{sec:stm_ease_of_use}
Through out the literature, one of the main reasons for investigating \ac{STM} as a synchronization mechanism is the claim of \ac{STM} being easier to use than locking and in particular fine grained locking. This section examines two studies into this claim. \bsref{sec:stm_ease_rossbach} examines a study conducted by Rossbach et al while \bsref{sec:stm_ease_pankratius} presents a similar study conducted by Pankratius et al.
\subsubsection{Rossbach et al}
\label{sec:stm_ease_rossbach}
In \cite{rossbach2010transactional} Rossbach et al. presents a study into the ease of \ac{TM}. The study is conducted over a period of three years tasking students in a \ac{OS} class at the Texas University at Austin with producing a number of concurrent implementations using coarse grained locking, fine grained locking, monitors, and \ac{STM}. Over the course of these three years a total of 237 students produced 1323 concurrent implementations. 

After finishing the implementations, students where given a questionnaire asking them to supplied their time spent on designing, coding and debugging the different implementation tasks, as well as ranking the used concurrency models according to syntax and the ease with which the student could reason about the model. The survey showed that students spend more time coding implementations based on fine grained locking and monitors than implementations based on \ac{STM} and coarse grained locking\cite[p. 51]{rossbach2010transactional}. Furthermore students spent more time debugging implementations based on fine grained locking and monitors than implementations based on coarse grained locking and \ac{STM}\cite[p. 51]{rossbach2010transactional}. Furthermore the students ranked coarse grained locking as both having the best syntax and easiest to think about followed by \ac{STM}, fine grained locking and monitors in the mentioned order.

In addition to surveying students the authors examine the implementations for errors, producing a taxonomy of the errors made, as well as a presenting their frequency. The examination shows that atleast 50\% of students made atleast one error in the fine grained locking implementations, while less that 20\% of students made and error in the \ac{STM} based implementations. 

To sum up, \cite{rossbach2010transactional} shows how students find coarse grained locking easier than \ac{STM}, fine grained locking, and monitors in the mentioned order\cite[p. 54]{rossbach2010transactional}. A examination of the errors rates show that students where much more likely to make mistakes in the implementations based on fine grained locking and monitors than the implementations based on \ac{STM}\cite[p. 54]{rossbach2010transactional}. It is worth noting that the study employed two different \ac{STM} implementations during the course of the study and that both of these implementations have a more baroque syntax that the atomic block discussed in \bsref{sec:stm_common_constructs}\cite[p. 49]{rossbach2010transactional}. Both factors that can have impacted the results of the study.

\subsubsection{Pankratius et al}
\label{sec:stm_ease_pankratius}
In \cite{pankratius2009does} Pankratius et al presents a study comparing \ac{TM} to locking as a synchronization mechanism. The study was conducted using 12 students, divided into teams of two, and tasking them with developing a parallel desktop search engine over the course of 15 weeks. Half the teams where restricted to using locks while the other half had to employ \ac{TM}. Both implementations where restricted to using C++. The locking teams employed Pthreads\cite[p. 2]{pankratius2009does} while the \ac{TM} employed Intel’s STM compiler\cite[p. 3]{pankratius2009does}.

The study shows that the first team to produce a working search engine was the winning \ac{TM}\cite[p. 6]{pankratius2009does}. The team had a working prototype after 5 weeks.   The locking teams spend more time debugging due to segmentation faults\cite[p. 6]{pankratius2009does}. As with the study examined in \bsref{sec:stm_ease_rossbach} the students where presented with a survey. The survey shows that the  winning \ac{TM} based team thought they where not progressing fast enough due to having to use transactions even though they had the first prototype and the least effort of all teams while lock based teams though they where progressing fast even though requiring more effort\cite[p. 6]{pankratius2009does}. Expert reviews revealed that the \ac{TM} based implementations where easier to understand and required fewer parallel consructs\cite[p. 6]{pankratius2009does}. All teams, including the winning \ac{TM} team, had data races which where detected after hand in by code inspection\cite[p. 6]{pankratius2009does}. The winning \ac{TM} team spent less time than the winning lock team and had better performance\cite[p. 23]{pankratius2009does}. All locks based teams attempted to scale by employing many locks (up to 1600),  this proved difficult\cite[p. 23]{pankratius2009does}.

Two of the \ac{TM} teams used locks for parts of their implementations, one team had a producer consumer setup which was controlled by a semaphore, while another teams used lock to synchronize a section with intensive\cite[p. 5]{pankratius2009does}. Pankratius et al make the case for locking and \ac{TM} coexisting rather than excluding one another.

\section{\acs{STM} Characteristics}
\label{sec:stm_eval}
This section presents how the \ac{STM} concurrency model relates to the selected characteristics presented in \bsref{chap:char}. \andreas{Should we describe which "variant" of the model we evaluate?}

\subsection{Implicit or Explicit Concurrency}
\ac{STM} as a concurrency model is build upon the constructs of threads and atomic blocks. Threads are used in order to introduce concurrency. To mitigate race conditions critical regions are specified where the program should be executed as a transaction and managed by the \ac{STM} system. It is the task of the programmer to explicitly employ these constructs, hence \ac{STM} employs explicit concurrency. The exact placement is shown in \bsref{fig:stm_char_impli_expli}.

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/stm/figures/stm_char_implicit_explicit} 
 \caption{\ac{STM} on the Implicit - Explicit concurrency spectrum}
\label{fig:stm_char_impli_expli}
\end{figure}

\subsection{Fault Restrictive or Expressive Model}
\ac{STM} express concurrency by starting threads and synchronising access to shared memory. The synchronization between threads is delegated to the \ac{STM} system. Furthermore \ac{STM} limits the number of concurrency related errors which the programmer has to reason about. As such we say that \ac{STM} is an expressive concurrency model with fault restrictive elements keeping it for being considered truly expressive\andreas{Maybe we should mention that it depends on the implementation? Some got orElse and retry, others nothing}. The exact placement of \ac{STM}, on the fault restrictive - expressive spectrum, is depicted in \bsref{fig:stm_char_fault_expressive}.

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/stm/figures/stm_char_fault_expressive} 
 \caption{\ac{STM} on the Fault Restrictive - Expressive spectrum}
\label{fig:stm_char_fault_expressive}
\end{figure}

\subsection{Pessimistic or Optimistic Model}
As described in \bsref{sec:stm_stm} \ac{STM} transactions are executed concurrently. If the execution is successful, the transaction commits. Such an approach corresponds well with an optimistic approach to concurrency and this is also the consensus in the relevant literature. Guerraoui et al, among others, explicitly state that \ac{STM} is an optimistic model\cite[p. 1]{guerraoui2005toward}. As described in \bsref{sec:stm_conflict_detection}, some \ac{STM} implementations employ eager conflict detection aimed at aborting conflicted transactions as soon as possible. The overall strategy of the model however remains optimistic. Therefore we say that \ac{STM} is a optimistic concurrency model. The exact placement is depicted in \bsref{fig:stm_char_pes_opti}.

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/stm/figures/stm_char_pessimistic_optemistic} 
 \caption{\ac{STM} on the Pessimistic - Optimistic spectrum}
\label{fig:stm_char_pes_opti}
\end{figure}

\subsection{Readability and Writability}
For the reasons described in \bsref{subsec:tl_charac_read_and_write} the evaluation of the elements common to readability and writability will be presented first, followed by a presentation of the readability evaluation and the writability specific evaluations.

\subsubsection{Simplicity}
\label{subsec:stm_char_simplicity}
While \ac{STM} builds upon the shared memory also present in the \ac{TL} concurrency model it substitutes locking with memory transactions. As discussed in \bsref{subsec:stm_irreversible_actions}\andreas{Er det irreversible actions vi vil refere til?} \ac{STM} avoid many of the concurrency related issues discussed that plague the  \ac{TL} concurrency model, contributing positively to its simplicity. The programmer does however still have to explicitly state when transaction are to be applied.\andreas[inline]{A lot of TL comparison, but hard to avoid if we want to make that point}

In \bsref{sec:stm_ease_of_use} we discuss two studies into the ease of use of \ac{STM}. The first study reveals that students make fewer errors using \ac{STM} memory than with fine grained locking. Students do however not find \ac{STM} strictly easier than fine grained locking. Rossbach et al. note that students found the concept of transactions difficult to understand at first. The second study revealed that students had a hard time predicting the performance of transaction and as a result had a hard time tuning performance.

As discussed in \bsref{subsec:stm:side_effects} and \bsref{subsec:stm_irreversible_actions}, transactions have problems composing with existing programming concepts such as \ac{IO}, exceptions and native method calls. Additional strain is put unto the programmer when combining these constructs with transactions reducing the simplicity of the model.

Based on these observations, we say that \ac{STM} resides towards the high end of the low - high simplicity spectrum. While \ac{STM} addresses many of the issues that plague the \ac{TL} concurrency model it introduces a number of new issues. These issues along with the findings in the studies discussed in \bsref{sec:stm_ease_of_use} keep \ac{STM} from having high simplicity. The exact position on the low - high simplicity spectrum is depicted in \bsref{fig:stm_char_simplicity}.\andreas[inline]{Again, some TL. Hard to avoid}

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/stm/figures/stm_char_simplicity} 
 \caption{\ac{STM} on the Low - High simplicity spectrum}
\label{fig:stm_char_simplicity}
\end{figure}

\subsubsection{Orthogonality}\label{sec:stm_orthogonality}
\label{subsec:stm_orthogonality}
The \ac{STM} concurrency model consists of a few well defined\andreas{Depends, do we count retry, and orElse?} constructs: threads, communication through shared memory and synchronization using transactions. These constructs can be combined to produce concurrent implementations. As discussed in \bsref{sec:stm_composability} \ac{STM} transactions can be nested, allowing the composition of code segments employing transactions. The composability problems described in \bsref{subsec:stm:side_effects} and \bsref{subsec:stm_irreversible_actions}\andreas{Is that composability problems?} however negatively effect the models orthogonality.

As discussed in \bsref{subsec:stm:side_effects} and \bsref{subsec:stm_irreversible_actions}, transactions have problems composing with existing programming concepts such as \ac{IO}, exceptions and native method calls. This of course reduces its orthogonality.

\kasper[inline]{Retry/orElse}
%In order to handle conditional synchronization the \bscode{retry} and \bscode{orElse} constructs. 

Based on these observations we say that \ac{STM} has high orthogonality limited by poor composition with some existing constructs. The position of \ac{STM} on the low - high orthogonality spectrum is shown in \bsref{fig:char_stm_orthogonality}.

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/stm/figures/stm_char_orthogonality} 
 \caption{\ac{STM} on the low - high orthogonality spectrum}
\label{fig:char_stm_orthogonality}
\end{figure}

\subsubsection{Readability evaluation}
\kasper[inline]{Issue med numerering af referenced sektioner}
As described in \bsref{subsec:stm_char_simplicity} the simplicity of the \ac{STM} concurrency model is residing towards the high end of the low - high simplicity spectrum. In \bsref{subsec:stm_orthogonality} we say that the orthogonality resides towards the high end of the low - high orthogonality spectrum, limited by poor composition with existing language constructs. These results directly influence the readability of the \ac{STM} concurrency model negatively.

The \ac{STM} concurrency model often separates the introduction of concurrency, from the synchronization in form of transactions. Such separation makes it harder for the reader to reason about the execution path. By employing transactions the reader does however not have to reason about lock ordering\andreas{Replace with deadlock?}, which as discussed in \bsref{subsec:tl_char_readability} requires the programmer to reason about every code segment in which locks are employed.

The studies by Rossbach et al and Pankratius et al, discussed in \bsref{sec:stm_ease_of_use}, shows that the concept of transactions can be hard to understand at first, especially when estimating and predicting performance. Understanding the concepts of transactions is key to reasoning about synchronization using \ac{STM}, especially when also considering the \bscode{retry} and \bscode{orElse} constructs discussed in \bsref{subsec:stm_conditional_synchronization}.

Considering these observations as well as the evaluation of simplicity and orthogonality we say that the \ac{STM} concurrency model is slightly towards the high end of the low - high readability spectrum. While \ac{STM} addresses many of the more pressing issues found in the \ac{TL} concurrency model, it still relies on shared memory concurrency and applying synchronization to critical regions. This approach has issue with code fragmentation as well as identifying critical regions. Ultimately this, along with the other observations, keeps \ac{STM} from obtaining a high readability score. The exact placement \ac{STM} on the low - high readability spectrum is depicted in \bsref{fig:char_stm_readability}.

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/stm/figures/stm_char_readability} 
 \caption{\ac{STM} on the low - high readability spectrum}
\label{fig:char_stm_readability}
\end{figure}

\subsubsection{Level of abstraction}\label{sec:stm_level_of_abstraction}
The threads and shared memory used by \ac{STM} are directly related to the \acp{OS} process/thread model described in \bsref{sec:processes_threads}. Synchronization is accomplished using the concept of memory transactions. As such, the details of how synchronization is achieved are abstracted away. That is, transactions say that synchronization should be applied to a code segment while locking says how synchronization should be applied. The abstraction is however somewhat obstructed by transactions combining poorly with some existing language constructs such as exceptions and \ac{IO}, as described in \bsref{subsec:stm:side_effects} and \bsref{subsec:stm_irreversible_actions}.\kasper{Insert reference when done}

The employed isolation level, described in \bsref{subsec:isolation_level}, impacts the level of abstraction provided by a given \ac{STM} implementation. Under weak isolation the programmer has to reason about non transactional code interfering with transactional code. Strong isolations abstracts away this issue.

While the \ac{STM} concurrency model in some aspects are close to the underlying \ac{OS} constructs, the concept of memory transactions represent a more high level and declarative approach to synchronization. Based on these observations, we say that \ac{STM} resides slightly towards the lower end of the low - high level of abstraction spectrum. The exact positions is depicted in \bsref{fig:char_stm_level_of_abstraction}.

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/stm/figures/stm_char_level_of_abstraction} 
 \caption{\ac{STM} on the low - high level of abstraction spectrum}
\label{fig:char_stm_level_of_abstraction}
\end{figure}

\subsubsection{Expressivity}\label{sec:stm_expressivity}
%The level of abstraction and expressivity of a concurrency model are tightly coupled. As such the models level of abstraction also impact its expressivity. This is also the case for \ac{STM}.

\ac{STM} handles many of the issues, such as deadlocks, that plague the \ac{TL} concurrency model. Not having to reason about these issues, makes expressing intent easier. 

Transactions not combining\andreas{Earlier we used the term composed} well with existing language constructs limit the expressivity of the model. Constructs such as exceptions and \ac{IO} currently either lead to non desirable implementation strategies or are simply prohibited inside transactions. As a result the expressivity of the \ac{STM} concurrency model suffers.

\ac{STM} builds upon threads and shared memory which limits its expressivity. Transactions do however represent a more declarative and expressive approach for specifying synchronization. Based on these observations we say that \ac{STM} resides slightly towards the high end, of the low - high expressivity spectrum. The exact placement is depicted in \bsref{fig:char_stm_expressivity}.

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/stm/figures/stm_char_expressivity} 
 \caption{\ac{STM} on the low - high expressivity spectrum}
\label{fig:char_stm_expressivity}
\end{figure}

\subsubsection{Writability evaluation}
\ac{STM} allows the programmer to express synchronizations points in a declarative manner. That is, specifying what should be synchronized, rather than how. Abstracting away the details of how synchronization is achieved allows the programmer to focus on specifying other aspects of the implementation, such as a clean design and code reuse, instead of dealing with the low level details of synchronization. The programmer is however not totally liberated from dealing with low level constructs as \ac{STM} still relies on threads and shared memory. Handling such low level constructs limit the models expressivity and in turn its writability.

Based on these observations, along with the evaluation of simplicity, orthogonality, level of abstraction and expressivity, we say that \ac{STM} resides slightly towards the high end, of the low - high writability spectrum. The exact position of the \ac{STM} concurrency model is shown in \bsref{fig:char_stm_writability}.

\begin{figure}[htbp]
\centering
 \includegraphics[width=0.9\textwidth]{\rootpath/worksheets/stm/figures/stm_char_writability} 
 \caption{\ac{STM} on the low - high writability spectrum}
\label{fig:char_stm_writability}
\end{figure}

\worksheetend
