\makeatletter \@ifundefined{rootpath}{\input{../../setup/preamble.tex}}\makeatother
\worksheetstart{Software Transactional Memory}{1}{November 7, 2013}{Andreas}{../../}
This chapter investigates \ac{STM} as a concurrency model. In \bsref{sec:stm_keyconcepts}, the key concepts of \ac{STM} are described. \bsref{sec:stm_issues} documents the concurrency issues introduced by \ac{STM}. \bsref{sec:stm_discussion} discusses the properties of \ac{STM}. Finally, in \bsref{sec:stm_eval} an evaluation of \ac{STM} as a concurrency model is conducted.
\label{chap:stm}
\kasper[inline]{Look in "kandidat opgave/literature/STM/State of the art" and TM book for talking about STM implementations. Eg time based STM}

\section{Key Concepts}
\label{sec:stm_keyconcepts}
This section presents the key concepts of \ac{STM}. It clarifies the concepts of \ac{STM}, so the discussion and comparison in the subsequent sections can be at a higher level of abstraction.

\subsection{\acl{TM}}
\label{sec:tmevo}
In \cite{herlihy1993transactional} the authors proposes a way to implement \ac{TM} at hardware level. Due to the inflexible properties of hardware, i.e. fixed instruction set and limited register size, \ac{TM} implemented on hardware is limited to existing instructions and can only handle transactions of limited size\cite{dragojevic2011stm}. This causes high implementation and verification costs\cite{cascaval2008software}. \ac{HTM} also exposes low level hardware details and limitations\cite{herlihy2011tm}, which preferably should be abstracted away from the programmer, to ensure semantic correctness of the transactions regardless of the hardware limitations. 

Due to these caveats, a software based solution is presented by \cite{shavit1997software}. This solution, entirely implemented as software, is known as \acl{STM}. Being implemented as a software solution, \ac{STM} does not suffer the same issues as \ac{HTM}, but still provides the transactional semantics. However, providing these semantics in software only, comes with a performance penalty\cite{cascaval2008software}\cite{dragojevic2011stm}.

Recently \ac{HTM} has been adopted by Intel and IBM and integrated into the Haswell and POWER8 processors respectively\cite{Anthes:2014:RSP:2684442.2667109}. Researchers hope to develop a hybrid model, which leverages the low level \ac{TM} instructions on the \ac{CPU} for good performance, while providing a transactional programming model to the developer at software level, to make the high level programming simpler, efficient, and well structured\cite{Anthes:2014:RSP:2684442.2667109}.

Despite the recent development in the area of \ac{HTM}, the availability of \ac{HTM} or hybrids in high level programming languages is to our best knowledge non-existent. One could speculate, that the programming model to the programmer will remain unchanged, but the underlying runtime will benefit from the new \ac{HTM} semantics available, and therefore the characteristics of the \ac{STM} programming model could be the same. Due to these observations, \ac{STM} is the focal point of our investigation in \ac{TM} as a concurrency mechanism. 

\subsection{Transactional Properties}
\label{sec:stm_tm_properties}
\ac{TM} is based on the concept of a transaction. A transaction is a finite sequence of machine instructions, executed by a single process, satisfying following properties\cite[p. 2]{herlihy2011tm}.

\paragraph{Atomicity} By considering the instructions in a transaction as indivisible, atomicity ensures a shared effect of all the instructions in the transactions, either success or failure. That is, either all the instructions succeed to change the state of the system or none of them take effect e.g. if a single instruction in a transaction fails, all will fail.
\paragraph{Isolation} A transaction is only perceived before or after its execution, never in the middle. That is, the work of a transaction can be perceived to occur instantaneously. This can be either from the view of the entire system, or other transactions. We will elaborate on this in \bsref{subsec:isolation_level}. 

\ac{TM} can perform a group of memory-operations atomically\cite[48]{harris2005composable}\toby{Den står lidt som et fact der ikke bliver bygget mere på, måske byg denne sætning sammen med næste eller uddyb}. By utilizing the transactional approach, \ac{TM} serves as a concurrency control mechanism. By adhering to the aforementioned properties, \ac{TM} enables concurrent execution, while being semantically equivalent to serial execution of the same program.

\subsection{\acl{STM}}
\ac{STM} provides programmers with a transactional model, in software, through a library or compiler interface\cite{herlihy2011tm}. It seeks to solve the issues introduced by running multiple processes concurrently in a shared memory space, e.g. race conditions as discussed in \bsref{subsec:race_coditions}. To handle these challenges, \ac{STM} offers the programmer ways to define transaction scopes in critical regions. The transactions are executed concurrently, and if successful, changes are committed. If the transactions are not successful, it will be retried. Just by defining the critical regions, the \ac{STM} takes care of ensuring the atomicity and isolation leaving no work left for the programmer. 

As our preliminary investigation showed in \bsref{sec:prelim_stm}, a number of programming languages and libraries have emerged to support TM. We have chosen Clojure, since \ac{STM} is natively implemented in the language, and it runs on the \ac{JVM}. The example in \bsref{lst:stmexample} demonstrates a transaction in Clojure on line 5, specified with the \bscode{dosync} function. Two accounts, \bscode{account1} and \bscode{account2} respectively, are defined as a reference to an amount. The function \bscode{transfer} takes an amount, and two accounts as parameters. In a transaction, it then transfers the amount given, from one account, to the other.

\begin{lstlisting}[label=lst:stmexample,
  caption={STM in Clojure},
  language=Lisp,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings}]  % Start your code-block

	(def account1 (ref 100))
	(def account2 (ref 0))

	(defn transfer [amount from to]
    	(dosync
    		(alter from - amount)
    		(alter to + amount)))
       
\end{lstlisting}

To clarify the effect of using \ac{STM}, \bsref{fig:transaction} visualizes the flow of an example of two transactions running concurrently. Both transactions \bscode{t1} and \bscode{t2} are in the same process, and therefore share memory. The variable \bscode{x} is stored in this memory. Both transactions have a reference to variable x. We use the concept of revisions of a variable, to describe how the value of it evolves. First off, both \bscode{t1} and \bscode{t2} are reading the initial value of x. They want to perform a statement to update the value of x, leading to a race condition. \bscode{t1} finishes its statement first, and wants to commit its transaction. This is allowed, since the revision of x is unchanged since the read. Afterwards, \bscode{t2} wants to commit its transaction. This is disallowed, since the revision of x now has increased. \bscode{t2} then retries its transaction, by re-reading the value of x, performing the statement again, and committing the transaction. This is now allowed, since x is the same revision as when it was read by \bscode{t2}. It is clear from the example given, that \ac{STM} remedied the risk of race conditions.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{\rootpath/worksheets/stm/figures/transaction}
\caption{Two transactions share memory and both have a reference to variable x. They have a racecondition, both doing calculations based on x, and writing back to x. \ac{STM} ensures that there is no lost update when t2 attempts to write, and enforces a recalculation with the new x value.}\label{fig:transaction}
\end{figure}

\subsection{Common Language Constructs}
\label{sec:stm_common_constructs}
Languages supporting \ac{STM} must encompass some language construct for specifying that a section of code should be executed as a transaction and managed by the \ac{STM} system. This basic language construct is often referred to as the \bscode{atomic} block\cite[p. 49]{harris2005composable}\cite[p. 3]{harris2003language}. The purpose of the \bscode{atomic} block is to allow programmers to specify that a section of code should be executed atomically and isolated as described in \bsref{sec:stm_tm_properties}. The basic concepts of the atomic block is exemplified in \bsref{lst:stm_atomic_block}. Exactly how a transaction scope is defined, varies between \ac{STM} implementations. As an example, Clojure employs the \bscode{dosync} function as shown on line 5 in \bsref{lst:stmexample} while a library based systems such as JDASTM\cite{ramadan2009committing} uses calls to \bscode{startTransaction} and \bscode{commitTransaction} methods.

\begin{lstlisting}[label=lst:stm_atomic_block,
  caption={The atomic block},
  language=Lisp,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic}]  % Start your code-block

	atomic{
		v1 = x;
		v2 = y;
		z  = v1 / v2;	
	}
       
\end{lstlisting}

\subsubsection{Conditional Synchronization}
A common tasks in concurrent programming is waiting on some event to occur before executing some code. As an example consider a concurrent queue shared between multiple threads in a producer consumer setup. It will be useful to only have a consumer dequeue an item whenever one is available. Accomplishing this without the need for busy waiting would also be preferable.

In \cite{harris2005composable} Harris et al. introduces the \bscode{retry} statement for assisting in conditional synchronization within the context of \ac{STM}. The \bscode{retry} statement is explicitly placed by programmers within a \bscode{atomic} block. If a transaction encounters a retry statement during its execution it indicates that the transaction is not yet ready to run and the transaction should be aborted and retried at some point later in time\cite[p. 73]{harris2010transactional}. A key point here is that the transaction is not retried immediately. The thread executing the transaction instead blocks, waiting to be awoken when the transaction is to be retried. The transaction is typically retired when one of the variables involved in the transaction is updated by another transaction\cite[p. 51]{harris2005composable}. By blocking the thread instead of repeatedly checking the condition, busy waiting is avoided. Furthermore the retry statement is not subject to the lost wake up problem which exists when doing conditional synchronization using monitors\cite[p. 2081]{herlihy2011tm}.

A transaction using the \bscode{retry} statement is shown in \bsref{lst:stm_retry}. If the queue is empty the transaction executes the retry statement of line 3, blocking the transaction until it is retired at a later time.
\begin{lstlisting}[label=lst:stm_retry,
  caption={The retry statement},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry}]  % Start your code-block

	atomic{
		if(queue.isEmpty())
			retry;
		item = queue.dequeue;
		//process item
	}
       
\end{lstlisting}

In addition to the \bscode{retry} statement Harris et al. proposes the \bscode{orElse} block. The \bscode{orElse} block handles the case of waiting on one of many conditions to be true by combining a number of transaction alternatives. The alternatives are evaluated in left-to-right order and only one of the alternatives is committed\cite[p. 52]{harris2005composable}. The \bscode{orElse} block works in conjunction with the \bscode{retry} statement to determine which alternative to execute. An example of a transaction employing the \bscode{orElse} block is shown in \bsref{lst:stm_orelse}. If an alternative executes without encountering a retry statement it gets to commit and the other alternatives are never executed\cite[p. 74]{harris2010transactional}. If an alternative however encounters a \bscode{retry} statement its work is undone and the next alternative in the chain is executed\cite[p. 74]{harris2010transactional}. If the last alternative encounters a \bscode{retry} statement the transaction as a whole is blocked awaiting a retry at a later time\cite[p. 74]{harris2010transactional}.

\begin{lstlisting}[label=lst:stm_orelse,
  caption={The orElse block},
  language=Java,  
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  morekeywords={atomic, retry, orElse}]  % Start your code-block

	atomic{
		{
			if(queue.isEmpty())
				retry;
			item = queue.dequeue;
		}orElse{
			if(queue2.isEmpty())
				retry;
			item = queue2.dequeue;
		}orElse{
			if(queue3.isEmpty())
				retry;
			item = queue3.dequeue;
		}
	}
       
\end{lstlisting}

\subsection{Zombie Transactions}
\label{subsec:zombie}
A zombie transaction is a transaction which will eventually abort, but have not yet discovered so. This happens, when a transaction have observed an inconsistent read-set\cite[p. 196]{dice2006transactional}. E.g. if a transaction reads the value of a variable, which is then updated by another transaction afterwards. This is exactly the case of \bscode{t2} in the example in \bsref{fig:transaction}. 

\subsection{Variations in \ac{STM} Design}
Different approaches for designing \ac{STM} systems exists. Many of the approaches represent a trade off between different aspects of the system. This section describes a number of design issues as well as the trade off's they represent.

\subsubsection{Level of Isolation}
\label{subsec:isolation_level}
Within the context of \ac{STM} there exists two different isolation levels: weak isolation and strong isolation. Isolation describes how parts of a system perceives transactions. Isolation level is in some literature also referred to as atomicity level\cite[p. 30]{harris2010transactional}.

With the guarantee of isolation, a transaction is perceived as one atomic step. That is, the intermediate states present during the execution of the transaction are not perceived by other parts of the systems, only the committed values become visible to other parts of the system. This always holds in the case of transactions perceiving other transactions. However, if a thread executes transactional code over some data, and another thread executes non-transactional code over the same data, the concepts of weak and strong isolation handle this differently.

In the case of strong isolation it is guaranteed that transactions are atomic with respect to non-transactional access\cite[p. 2083]{herlihy2011tm}. This means, that if the same variable is used in a transaction, and outside of a transaction, the \ac{STM} implementation will ensure that the variable is also atomic outside of the transaction scope. Since the \ac{STM} must guarantee isolation outside of the transaction scope, this comes with a cost in performance\cite{herlihy2011tm}. 

In the case of weak isolation, it is only guaranteed that transactions are atomic with respect to other transactions. That is, it is up to the programmer to ensure that the transactions does not affect the rest of the system, and vice versa. 

\subsubsection{Eager vs Lazy Updating}
Updating memory in a \ac{STM} implementation can be done using one of two different approaches: eager or lazy updating.

Eager updating updates the memory associated with a variable directly. Eager updating is also referred to as in-place-updating, as updates are written into the existing memory location\cite[p. 35]{afek2011lowering}. \ac{STM} implementations using eager updating, must maintain an undo log, which stores information about any writes made within transactions. The undo log is used to undo the effects of a transaction when a transaction conflicts\cite[p. 2084]{herlihy2011tm}.

Lazy updating takes the opposite approach and writes updates to local versions of the effected data\cite[p. 2084]{herlihy2011tm}. If the transaction commits, the local changes are written to the actual memory locations, while an abort causes the local changes to be discarded.\toby{Evt. noget om at lazy updating bruger mere plads fordi vi har kopier fremfor en changelog, men at hvis der så er conflicter er det nemmere at discare kopier fremfor at skulle til at udføre en changelog.}

Eager updating allows efficient commit of transactions but makes it harder to ensure that zombie transactions sees consistent state\cite[p. 2084]{herlihy2011tm}\kasper{Mere om dette.}.

\subsubsection{Conflict Detection}
In the context of \ac{STM} a conflict is two transactions performing conflicting operations on the same data, resulting in only one of them being able to continue\cite[p. 20]{harris2010transactional}. A conflict arises if both transactions attempts to write to the same data, or if one transaction reads the data while the other writes to it. The act of determining whether a conflict has occurred is called conflict detection\cite[p. 20]{harris2010transactional}. Different ways of handling conflict detection exists. Eager conflict detection detects conflicts whenever a transaction attempts to access shared data, while lazy conflict detection detects conflicts just before a transaction is about to commit by validating the transactions data access\cite[p. 21]{harris2010transactional}. \toby{Evt. lidt uddybnede om hvad det betyder. Det er vel at noget med at med eager finder vi hurtigt ud af at der er lavet changes og kan hurtigt begynde forfra, men det er dyrt at tjekke hele tiden hvis der alligevel ikke var lavet changes hvorimod med lazy, der kunne der ske en ændring helt i starten af en anden transaktion, hvor man unøvendigt prøver at udføre en lang transaktion der kunne have været genstartet med eager}

Another distinction lies between what transactions are included when performing conflict detection. A \ac{STM} system employing tentative conflict detecting will include currently active transactions when detecting conflicts while a system using committed conflict detection only detects conflicts with committed transactions. Eager conflict detection is often coupled with tentative conflict detection while lazy conflict detection is often coupled with committed conflict detection\cite[p. 22]{harris2010transactional}. \toby{Hvad har de af virkninger? Altså pros og cons for begge ligesom ovenfor}

Conflict detection is highly related to the concepts of pessimistic or optimistic concurrency control. In pessimistic concurrency control conflicts are detected and resolved when they happen\cite[p. 20]{harris2010transactional} while optimistic concurrency control detects and resolves conflicts some time after they occur\cite[p. 20]{harris2010transactional}.

\subsubsection{Visible vs Invisible Reads}
When reading shared data \ac{STM} implementations can either employ visible, invisible or semivisible reads.

Using visible reads a \ac{STM} transaction communicate its operations to other transactions, by registering in shared memory whenever it reads a shared variable\cite[p. 2]{lev2009anatomy}\cite[p. 2085]{herlihy2011tm}. Other transactions, which are about to write to a shared variable, can then consult the written data to identify if they are about to produce a conflict. As transactions write exactly which transaction reads a variable, the writing transaction can choose to abort the reading transactions\cite[p. 2]{lev2009anatomy}.

Using invisible reads a \ac{STM} transaction does not communicate its operations to other transactions\cite[p. 114]{imbs2012virtual}. Each transaction instead maintain per read metadata which is used to validate the transaction whenever additional reads are performed\cite[p. 2085]{herlihy2011tm}.

Visible reads have the problem of being expensive and not scaling, while invisible reads are expensive due to their need for repeated validation. As such, more recent \ac{STM} implementations instead employ the semivisible read scheme\cite[p. 2085]{herlihy2011tm}.

Semivisible reads are similar to visible reads in that transaction communicate their reads to other transactions. Instead of communicating exactly what transaction read a shared variable, a transaction simply indicates that a given variable has been read by some transaction. Allowing other transaction to see that a conflict exists. A counter is maintained for each transaction indicating if any conflicts occured during its execution. Expensive validation can be avoided in the vast majority of cases by checking whether any conflicts occurred during the execution of a transaction\cite[p. 2]{lev2009anatomy}.

\subsubsection{Contention Managers}
Some \ac{STM} implementations delegate conflict resolution to a component called a contention manager\cite[p. 2085]{herlihy2011tm}. The contention manager also ensures that the \ac{STM} systems as a whole makes progress\cite[p. 1]{guerraoui2005toward}. Not all \ac{STM} implementations use a contention manager, but instead abort transactions immediately\cite[38]{riegel2013software}.

When a transaction detects that it is about to create a conflict it can either pause, attempting to let the transaction its about to conflict with finish, or it can proceed forcing the other transaction to abort. The decision can be delegated to a contention manager. The contention manager encapsulates the \ac{STM} implementations conflict resolution policy\cite[p. 2085]{herlihy2011tm}.

In \cite{scherer2004contention} the authors examine a number of contention manager implementation policies. Including policies based on time-stamps, alternating and karma. Benchmarking the policies reveals that all policies which performed well in atleast a single test performed abysmal in atleast one other test. So no single best contention management policy was identified.
\subsubsection{Implementation techniques}
Multiversion concurrency control\\
Time based STM\\


\section{Concurrency Issues}
In this section we present the concurrency issues related to the use of \ac{STM}. We will also relate to the concurrency issues discussed in \bsref{subsec:race_coditions} and \bsref{sec:tl_ci}.
\label{sec:stm_issues}

% Composition is possible in STM. Reference to Kaspers example about composition.
% STM compared to locks
\subsection{Race Conditions}
In a setting with shared memory and multiple threads, the risk of race conditions are present. In order to negate this risk, \ac{STM} enables the programmer to define blocks of code, that must be executed with atomic semantics. The atomicity of \ac{STM} ensures that the execution appears as instantaneous, hence no race conditions can occur between transactions. This holds for both \ac{STM} with weak and strong isolation level.

As the programmer explicitly has to mark code in atomic blocks to ensure safety, the risk of the programmer not marking the code, will make the code unsafe to race conditions. This holds true only for weak isolation level.

\subsection{Side Effects and Transactions}
It is problematic to handle side-effects happening inside a transactions. Exceptions thrown inside a transaction should only be propagated when a transaction is successful, since this is the only case a transaction causes changes impacting the rest of the system. By using this approach, the option to roll back any updates made in an transaction until the point where the exception is thrown\cite[p. 2]{harris2005exceptions}.

\andreas[inline]{GOOD MONDAY MORNING :) WORK HERE!}
modifications to objects that have multiple references. 
How to handle this, varies in the different implementations. One option is, to only allow a specific reference type to be used inside a transaction. Another option is, 

\subsection{Native methods}
\ac{IO} performed on a disk. These are irreversible actions, and even by not committing the result of a transaction, the transaction have still affected the system. 


\subsection{Performance}
Combined with the retries of transaction, and the result could be a brutal performance hit, or miscalculations.

Interaction with code that cannot be transactionalized\\

Structuring concurrent programs that seeks to provide better scalability and ease-of-use than conventional approaches based on locks and conditions.

\kasper[inline]{STM og eksterne side effects. Så som skrive til fil i transaktion.}

Speculative transactions\\
Exceptions\\
Interaction with code that cannot be transactionalized\\
Livelock\\





\section{Discussion}
\label{sec:stm_discussion}

\subsection{Compared to TL}
\andreas[inline]{The titles should be refined}
% Raceconditions. Transaction ensures atomicity (clojure got strong atomicity), and isolation. Due to this, the result of concurrent calculations will be the same, as if it was executed sequencially. 
% Deadlocks...

\subsection{Composability}
\subsection{Ease of Use}
Through out the literature, one of the main reasons for investigating \ac{STM} as a synchronization mechanism is the claim of \ac{STM} being easier to use than locking and in particular fine grained locking. This section examines two studies into this claim. \bsref{sec:stm_ease_rossbach} examines a study conducted by Rossbach et al while \bsref{sec:stm_ease_pankratius} presents a similar study conducted by Pankratius et al.
\subsubsection{Rossbach et al.}
\label{sec:stm_ease_rossbach}
In \cite{rossbach2010transactional} Rossbach et al. presents a study into the ease of \ac{TM}. The study is conducted over a period of three years tasking students in a \ac{OS} class at the Texas University at Austin with producing a number of concurrent implementations using coarse grained locking, fine grained locking, monitors, and \ac{STM}. Over the course of these three years a total of 237 students produced 1323 concurrent implementations. 

After finishing the implementations, students where given a questionnaire asking them to supplied their time spent on designing, coding and debugging the different implementation tasks, as well as ranking the used concurrency models according to syntax and the ease with which the student could reason about the model. The survey showed that students spend more time coding implementations based on fine grained locking and monitors than implementations based on \ac{STM} and coarse grained locking\cite[p. 51]{rossbach2010transactional}. Furthermore students spent more time debugging implementations based on fine grained locking and monitors than implementations based on coarse grained locking and \ac{STM}\cite[p. 51]{rossbach2010transactional}. Furthermore the students ranked coarse grained locking as both having the best syntax and easiest to think about followed by \ac{STM}, fine grained locking and monitors in the mentioned order.

In addition to surveying students the authors examine the implementations for errors, producing a taxonomy of the errors made, as well as a presenting their frequency. The examination shows that atleast 50\% of students made atleast one error in the fine grained locking implementations, while less that 20\% of students made and error in the \ac{STM} based implementations. 

To sum up, \cite{rossbach2010transactional} shows how students find coarse grained locking easier than \ac{STM}, fine grained locking, and monitors in the mentioned order\cite[p. 54]{rossbach2010transactional}. A examination of the errors rates show that students where much more likely to make mistakes in the implementations based on fine grained locking and monitors than the implementations based on \ac{STM}\cite[p. 54]{rossbach2010transactional}. It is worth noting that the study employed two different \ac{STM} implementations during the course of the study and that both of these implementations have a more baroque syntax that the atomic block discussed in \bsref{sec:stm_common_constructs}\cite[p. 49]{rossbach2010transactional}. Both factors that can have impacted the results of the study.

\subsubsection{Pankratius et al}
\label{sec:stm_ease_pankratius}
In \cite{pankratius2009does} Pankratius et al presents a study comparing \ac{TM} to locking as a synchronization mechanism. The study was conducted using 12 students, divided into teams of two, and tasking them with developing a parallel desktop search engine over the course of 15 weeks. Half the teams where restricted to using locks while the other half had to employ \ac{TM}. Both implementations where restricted to using C++. The locking teams employed Pthreads\cite[p. 2]{pankratius2009does} while the \ac{TM} employed Intel’s STM compiler\cite[p. 3]{pankratius2009does}.

The study shows that the first team to produce a working search engine was the winning \ac{TM}\cite[p. 6]{pankratius2009does}. The team had a working prototype after 5 weeks.   The locking teams spend more time debugging due to segmentation faults\cite[p. 6]{pankratius2009does}. As with the study examined in \bsref{sec:stm_ease_rossbach} the students where presented with a survey. The survey shows that the  winning \ac{TM} based team thought they where not progressing fast enough due to having to use transactions even though they had the first prototype and the least effort of all teams while lock based teams though they where progressing fast even though requiring more effort\cite[p. 6]{pankratius2009does}. Expert reviews revealed that the \ac{TM} based implementations where easier to understand and required fewer parallel consructs\cite[p. 6]{pankratius2009does}. All teams, including the winning \ac{TM} team, had data races which where detected after hand in by code inspection\cite[p. 6]{pankratius2009does}. The winning \ac{TM} team spent less time than the winning lock team and had better performance\cite[p. 23]{pankratius2009does}. All locks based teams attempted to scale by employing many locks (up to 1600),  this proved difficult\cite[p. 23]{pankratius2009does}.

Two of the \ac{TM} teams used locks for parts of their implementations, one team had a producer consumer setup which was controlled by a semaphore, while another teams used lock to synchronize a section with intensive\cite[p. 5]{pankratius2009does}. The Pankratius et al make the case for locking and \ac{TM} coexisting rather than excluding one another.

\section{Evaluation of Characteristics}

% Is Transactional Programming Actually Easier, STM is easier to use: Pankratius, Rossbach\\
% Why is STM only a research toy
% Why STM can be more than a research toy
Transaction synchronization is optimistic\cite[p. 1]{guerraoui2005toward}.

\label{sec:stm_eval}
% Optimistic (retry, not wait)
\subsection{Implicit or Explicit Concurrency}
\subsection{Fault Restrictive or Expressive Model}
\subsection{Pessimistic or Optimistic Model}
\subsection{Readability and Writability}
\worksheetend